/**
 * MCP Connector Loader Template
 * Generated by EasyMCP
 * 
 * This file handles initialization, connection management, and lifecycle
 * of external service connectors. Supports credential injection, connection
 * pooling, health checks, and retry logic.
 */

// ============================================================================
// Placeholder for Connector Definitions - Populated during code generation
// ============================================================================
{{CONNECTOR_LIST}}

// ============================================================================
// Types
// ============================================================================

/**
 * Credential types supported
 */
type CredentialType = 'oauth' | 'api_key' | 'basic' | 'bearer' | 'none';

/**
 * OAuth credentials
 */
interface OAuthCredentials {
  type: 'oauth';
  clientId: string;
  clientSecret: string;
  accessToken?: string;
  refreshToken?: string;
  tokenUrl?: string;
  scopes?: string[];
  expiresAt?: number;
}

/**
 * API Key credentials
 */
interface ApiKeyCredentials {
  type: 'api_key';
  key: string;
  header?: string; // Header name, default 'X-API-Key'
  prefix?: string; // Prefix like 'Bearer ' or 'Api-Key '
}

/**
 * Basic auth credentials
 */
interface BasicCredentials {
  type: 'basic';
  username: string;
  password: string;
}

/**
 * Bearer token credentials
 */
interface BearerCredentials {
  type: 'bearer';
  token: string;
}

/**
 * No authentication
 */
interface NoCredentials {
  type: 'none';
}

/**
 * Union of all credential types
 */
type Credentials = OAuthCredentials | ApiKeyCredentials | BasicCredentials | BearerCredentials | NoCredentials;

/**
 * Connection state
 */
type ConnectionState = 'disconnected' | 'connecting' | 'connected' | 'error' | 'reconnecting';

/**
 * Connector interface
 */
interface Connector {
  /** Unique connector name */
  name: string;
  /** Connector type (database, api, etc.) */
  type: string;
  /** Check if connected */
  isConnected(): boolean;
  /** Get connection state */
  getState(): ConnectionState;
  /** Connect to the service */
  connect(): Promise<void>;
  /** Disconnect from the service */
  disconnect(): Promise<void>;
  /** Reconnect to the service */
  reconnect(): Promise<void>;
  /** Check health of the connection */
  health(): Promise<boolean>;
  /** Get the underlying client */
  getClient<T>(): T | undefined;
  /** Optional initialization hook */
  onInit?: () => void | Promise<void>;
  /** Optional cleanup hook */
  onDestroy?: () => void | Promise<void>;
}

/**
 * Connector configuration
 */
interface ConnectorConfig {
  /** Unique connector name */
  name: string;
  /** Connector type (database, api, etc.) */
  type: string;
  /** Connection credentials */
  credentials: Credentials;
  /** Connection string or URL */
  connectionString?: string;
  /** Host for the service */
  host?: string;
  /** Port for the service */
  port?: number;
  /** Connection pool size */
  poolSize?: number;
  /** Connection timeout in ms */
  timeout?: number;
  /** Max retry attempts */
  maxRetries?: number;
  /** Initial retry delay in ms */
  retryDelay?: number;
  /** Whether connector is required for startup */
  required?: boolean;
  /** Additional options */
  options?: Record<string, unknown>;
}

/**
 * Connection pool entry
 */
interface PoolEntry<T> {
  /** The connection/client */
  client: T;
  /** When the connection was created */
  createdAt: number;
  /** When last used */
  lastUsedAt: number;
  /** Whether currently in use */
  inUse: boolean;
  /** Connection ID */
  id: number;
}

/**
 * Retry options
 */
interface RetryOptions {
  /** Max number of retries */
  maxRetries: number;
  /** Initial delay in ms */
  initialDelay: number;
  /** Max delay in ms */
  maxDelay: number;
  /** Backoff multiplier */
  multiplier: number;
  /** Whether to add jitter */
  jitter: boolean;
}

/**
 * Health check result
 */
interface HealthCheckResult {
  /** Connector name */
  name: string;
  /** Whether healthy */
  healthy: boolean;
  /** Response time in ms */
  responseTime?: number;
  /** Error message if unhealthy */
  error?: string;
  /** Last check timestamp */
  lastCheck: string;
}

// ============================================================================
// Retry Logic
// ============================================================================

/**
 * Default retry options
 */
const DEFAULT_RETRY_OPTIONS: RetryOptions = {
  maxRetries: 3,
  initialDelay: 1000,
  maxDelay: 30000,
  multiplier: 2,
  jitter: true,
};

/**
 * Calculate delay with exponential backoff
 */
function calculateBackoffDelay(
  attempt: number,
  options: RetryOptions = DEFAULT_RETRY_OPTIONS
): number {
  const delay = Math.min(
    options.initialDelay * Math.pow(options.multiplier, attempt),
    options.maxDelay
  );
  
  if (options.jitter) {
    // Add random jitter of Â±25%
    const jitter = delay * 0.25 * (Math.random() * 2 - 1);
    return Math.floor(delay + jitter);
  }
  
  return delay;
}

/**
 * Sleep for a given duration
 */
function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Execute a function with retry logic
 */
async function withRetry<T>(
  fn: () => Promise<T>,
  options: Partial<RetryOptions> = {},
  onRetry?: (attempt: number, error: Error, delay: number) => void
): Promise<T> {
  const opts = { ...DEFAULT_RETRY_OPTIONS, ...options };
  let lastError: Error | undefined;
  
  for (let attempt = 0; attempt <= opts.maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      
      if (attempt < opts.maxRetries) {
        const delay = calculateBackoffDelay(attempt, opts);
        onRetry?.(attempt + 1, lastError, delay);
        await sleep(delay);
      }
    }
  }
  
  throw lastError || new Error('Retry failed');
}

// ============================================================================
// Connection Pool
// ============================================================================

/**
 * Generic connection pool
 */
class ConnectionPool<T> {
  private pool: PoolEntry<T>[] = [];
  private nextId = 0;
  private config: {
    minSize: number;
    maxSize: number;
    acquireTimeout: number;
    idleTimeout: number;
    createFn: () => Promise<T>;
    destroyFn: (client: T) => Promise<void>;
    validateFn?: (client: T) => Promise<boolean>;
  };

  constructor(config: {
    minSize?: number;
    maxSize?: number;
    acquireTimeout?: number;
    idleTimeout?: number;
    createFn: () => Promise<T>;
    destroyFn: (client: T) => Promise<void>;
    validateFn?: (client: T) => Promise<boolean>;
  }) {
    this.config = {
      minSize: config.minSize ?? 1,
      maxSize: config.maxSize ?? 10,
      acquireTimeout: config.acquireTimeout ?? 30000,
      idleTimeout: config.idleTimeout ?? 300000,
      createFn: config.createFn,
      destroyFn: config.destroyFn,
      validateFn: config.validateFn,
    };
  }

  /**
   * Initialize the pool with minimum connections
   */
  async initialize(): Promise<void> {
    const promises: Promise<void>[] = [];
    for (let i = 0; i < this.config.minSize; i++) {
      promises.push(this.addConnection());
    }
    await Promise.all(promises);
  }

  /**
   * Add a new connection to the pool
   */
  private async addConnection(): Promise<void> {
    if (this.pool.length >= this.config.maxSize) {
      return;
    }

    const client = await this.config.createFn();
    this.pool.push({
      client,
      createdAt: Date.now(),
      lastUsedAt: Date.now(),
      inUse: false,
      id: this.nextId++,
    });
  }

  /**
   * Acquire a connection from the pool
   */
  async acquire(): Promise<T> {
    const startTime = Date.now();

    while (true) {
      // Look for an available connection
      const entry = this.pool.find(e => !e.inUse);
      
      if (entry) {
        // Validate the connection if validator is provided
        if (this.config.validateFn) {
          try {
            const valid = await this.config.validateFn(entry.client);
            if (!valid) {
              // Remove invalid connection and try again
              await this.removeEntry(entry);
              continue;
            }
          } catch {
            await this.removeEntry(entry);
            continue;
          }
        }

        entry.inUse = true;
        entry.lastUsedAt = Date.now();
        return entry.client;
      }

      // No available connection, try to create one
      if (this.pool.length < this.config.maxSize) {
        await this.addConnection();
        continue;
      }

      // Pool is at max capacity, wait
      if (Date.now() - startTime > this.config.acquireTimeout) {
        throw new Error('Connection acquire timeout');
      }

      await sleep(100);
    }
  }

  /**
   * Release a connection back to the pool
   */
  release(client: T): void {
    const entry = this.pool.find(e => e.client === client);
    if (entry) {
      entry.inUse = false;
      entry.lastUsedAt = Date.now();
    }
  }

  /**
   * Remove an entry from the pool
   */
  private async removeEntry(entry: PoolEntry<T>): Promise<void> {
    const index = this.pool.indexOf(entry);
    if (index !== -1) {
      this.pool.splice(index, 1);
      try {
        await this.config.destroyFn(entry.client);
      } catch {
        // Ignore destroy errors
      }
    }
  }

  /**
   * Drain and close all connections
   */
  async drain(): Promise<void> {
    const promises = this.pool.map(entry => 
      this.config.destroyFn(entry.client).catch(() => {})
    );
    await Promise.all(promises);
    this.pool = [];
  }

  /**
   * Get pool statistics
   */
  stats(): { total: number; inUse: number; available: number } {
    const inUse = this.pool.filter(e => e.inUse).length;
    return {
      total: this.pool.length,
      inUse,
      available: this.pool.length - inUse,
    };
  }

  /**
   * Prune idle connections
   */
  async pruneIdle(): Promise<number> {
    const now = Date.now();
    const toRemove = this.pool.filter(
      e => !e.inUse && now - e.lastUsedAt > this.config.idleTimeout
    );

    // Keep at least minSize connections
    const keepCount = Math.max(0, this.config.minSize - (this.pool.length - toRemove.length));
    const actualRemove = toRemove.slice(keepCount);

    for (const entry of actualRemove) {
      await this.removeEntry(entry);
    }

    return actualRemove.length;
  }
}

// ============================================================================
// Connector Registry
// ============================================================================

/**
 * Registry for managing connectors
 */
class ConnectorRegistry {
  private connectors = new Map<string, Connector>();
  private configs = new Map<string, ConnectorConfig>();
  private pools = new Map<string, ConnectionPool<unknown>>();
  private healthResults = new Map<string, HealthCheckResult>();

  /**
   * Register a connector
   */
  async register(connector: Connector, config?: ConnectorConfig): Promise<void> {
    if (!connector.name) {
      throw new Error('Connector must have a name');
    }

    if (this.connectors.has(connector.name)) {
      throw new Error(`Connector already registered: ${connector.name}`);
    }

    // Call onInit hook if provided
    if (connector.onInit) {
      try {
        await Promise.resolve(connector.onInit());
      } catch (error) {
        throw new Error(
          `Failed to initialize connector ${connector.name}: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    }

    this.connectors.set(connector.name, connector);
    if (config) {
      this.configs.set(connector.name, config);
    }
  }

  /**
   * Get a connector by name
   */
  get(name: string): Connector | undefined {
    return this.connectors.get(name);
  }

  /**
   * Check if a connector exists
   */
  has(name: string): boolean {
    return this.connectors.has(name);
  }

  /**
   * List all connectors
   */
  list(): Connector[] {
    return Array.from(this.connectors.values());
  }

  /**
   * Get connector names
   */
  names(): string[] {
    return Array.from(this.connectors.keys());
  }

  /**
   * Get connector config
   */
  getConfig(name: string): ConnectorConfig | undefined {
    return this.configs.get(name);
  }

  /**
   * Connect a specific connector
   */
  async connect(name: string): Promise<void> {
    const connector = this.connectors.get(name);
    if (!connector) {
      throw new Error(`Connector not found: ${name}`);
    }

    await connector.connect();
  }

  /**
   * Connect all connectors
   */
  async connectAll(): Promise<{ connected: string[]; failed: string[] }> {
    const connected: string[] = [];
    const failed: string[] = [];

    for (const [name, connector] of this.connectors) {
      try {
        await connector.connect();
        connected.push(name);
      } catch (error) {
        const config = this.configs.get(name);
        if (config?.required) {
          throw new Error(
            `Required connector failed to connect: ${name} - ${error instanceof Error ? error.message : String(error)}`
          );
        }
        failed.push(name);
        console.warn(`Optional connector failed to connect: ${name}`, error);
      }
    }

    return { connected, failed };
  }

  /**
   * Disconnect a specific connector
   */
  async disconnect(name: string): Promise<void> {
    const connector = this.connectors.get(name);
    if (!connector) {
      throw new Error(`Connector not found: ${name}`);
    }

    await connector.disconnect();
  }

  /**
   * Disconnect all connectors
   */
  async disconnectAll(): Promise<void> {
    const promises = Array.from(this.connectors.values()).map(connector =>
      connector.disconnect().catch(error => {
        console.warn(`Failed to disconnect ${connector.name}:`, error);
      })
    );

    await Promise.all(promises);
  }

  /**
   * Check health of a specific connector
   */
  async checkHealth(name: string): Promise<HealthCheckResult> {
    const connector = this.connectors.get(name);
    if (!connector) {
      return {
        name,
        healthy: false,
        error: 'Connector not found',
        lastCheck: new Date().toISOString(),
      };
    }

    const startTime = Date.now();
    try {
      const healthy = await connector.health();
      const result: HealthCheckResult = {
        name,
        healthy,
        responseTime: Date.now() - startTime,
        lastCheck: new Date().toISOString(),
      };
      this.healthResults.set(name, result);
      return result;
    } catch (error) {
      const result: HealthCheckResult = {
        name,
        healthy: false,
        responseTime: Date.now() - startTime,
        error: error instanceof Error ? error.message : String(error),
        lastCheck: new Date().toISOString(),
      };
      this.healthResults.set(name, result);
      return result;
    }
  }

  /**
   * Check health of all connectors
   */
  async checkAllHealth(): Promise<Record<string, HealthCheckResult>> {
    const results: Record<string, HealthCheckResult> = {};

    const checks = Array.from(this.connectors.keys()).map(async name => {
      results[name] = await this.checkHealth(name);
    });

    await Promise.all(checks);
    return results;
  }

  /**
   * Get last health check results
   */
  getHealthResults(): Record<string, HealthCheckResult> {
    const results: Record<string, HealthCheckResult> = {};
    for (const [name, result] of this.healthResults) {
      results[name] = result;
    }
    return results;
  }

  /**
   * Unregister a connector
   */
  async unregister(name: string): Promise<void> {
    const connector = this.connectors.get(name);
    if (!connector) {
      throw new Error(`Connector not found: ${name}`);
    }

    // Disconnect first
    try {
      await connector.disconnect();
    } catch {
      // Ignore disconnect errors
    }

    // Call onDestroy hook if provided
    if (connector.onDestroy) {
      try {
        await Promise.resolve(connector.onDestroy());
      } catch (error) {
        console.warn(
          `Warning: onDestroy hook failed for ${name}: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    }

    // Drain pool if exists
    const pool = this.pools.get(name);
    if (pool) {
      await pool.drain();
      this.pools.delete(name);
    }

    this.connectors.delete(name);
    this.configs.delete(name);
    this.healthResults.delete(name);
  }

  /**
   * Unregister all connectors
   */
  async unregisterAll(): Promise<void> {
    const names = Array.from(this.connectors.keys());
    for (const name of names) {
      try {
        await this.unregister(name);
      } catch (error) {
        console.warn(`Failed to unregister ${name}:`, error);
      }
    }
  }

  /**
   * Get pool for a connector
   */
  getPool<T>(name: string): ConnectionPool<T> | undefined {
    return this.pools.get(name) as ConnectionPool<T> | undefined;
  }

  /**
   * Set pool for a connector
   */
  setPool<T>(name: string, pool: ConnectionPool<T>): void {
    this.pools.set(name, pool as ConnectionPool<unknown>);
  }

  /**
   * Get connector count
   */
  get count(): number {
    return this.connectors.size;
  }

  /**
   * Get all connected connectors
   */
  getConnected(): string[] {
    return Array.from(this.connectors.entries())
      .filter(([_, connector]) => connector.isConnected())
      .map(([name]) => name);
  }
}

// ============================================================================
// Global Registry Instance
// ============================================================================

const connectorRegistry = new ConnectorRegistry();

// ============================================================================
// Credential Helpers
// ============================================================================

/**
 * Build authorization header from credentials
 */
function buildAuthHeader(credentials: Credentials): string | undefined {
  switch (credentials.type) {
    case 'basic': {
      const encoded = Buffer.from(
        `${credentials.username}:${credentials.password}`
      ).toString('base64');
      return `Basic ${encoded}`;
    }
    case 'bearer':
      return `Bearer ${credentials.token}`;
    case 'api_key':
      return credentials.prefix
        ? `${credentials.prefix}${credentials.key}`
        : credentials.key;
    case 'oauth':
      return credentials.accessToken
        ? `Bearer ${credentials.accessToken}`
        : undefined;
    case 'none':
    default:
      return undefined;
  }
}

/**
 * Get header name for credentials
 */
function getAuthHeaderName(credentials: Credentials): string {
  if (credentials.type === 'api_key' && credentials.header) {
    return credentials.header;
  }
  return 'Authorization';
}

/**
 * Check if OAuth token is expired
 */
function isTokenExpired(credentials: OAuthCredentials, bufferMs: number = 60000): boolean {
  if (!credentials.expiresAt) return false;
  return Date.now() + bufferMs >= credentials.expiresAt;
}

// ============================================================================
// Connector Initialization
// ============================================================================

/**
 * Create a base connector from config
 */
function createBaseConnector(config: ConnectorConfig): Connector {
  let state: ConnectionState = 'disconnected';
  let client: unknown = undefined;

  return {
    name: config.name,
    type: config.type,

    isConnected(): boolean {
      return state === 'connected';
    },

    getState(): ConnectionState {
      return state;
    },

    async connect(): Promise<void> {
      if (state === 'connected') return;

      state = 'connecting';
      try {
        // Base implementation - extend for specific connector types
        state = 'connected';
      } catch (error) {
        state = 'error';
        throw error;
      }
    },

    async disconnect(): Promise<void> {
      if (state === 'disconnected') return;

      try {
        client = undefined;
        state = 'disconnected';
      } catch (error) {
        state = 'error';
        throw error;
      }
    },

    async reconnect(): Promise<void> {
      state = 'reconnecting';
      await this.disconnect();
      await this.connect();
    },

    async health(): Promise<boolean> {
      return state === 'connected';
    },

    getClient<T>(): T | undefined {
      return client as T;
    },
  };
}

/**
 * Initialize a connector with retry logic
 */
async function initializeConnector(
  config: ConnectorConfig,
  options: {
    logger?: { info: Function; warn: Function; error: Function };
  } = {}
): Promise<Connector> {
  const logger = options.logger || console;
  const retryOptions: Partial<RetryOptions> = {
    maxRetries: config.maxRetries ?? 3,
    initialDelay: config.retryDelay ?? 1000,
  };

  logger.info(`Initializing connector: ${config.name} (${config.type})`);

  const connector = createBaseConnector(config);

  // Connect with retry
  await withRetry(
    () => connector.connect(),
    retryOptions,
    (attempt, error, delay) => {
      logger.warn(
        `Connector ${config.name} connection attempt ${attempt} failed: ${error.message}. ` +
        `Retrying in ${delay}ms...`
      );
    }
  );

  logger.info(`Connector initialized: ${config.name}`);
  return connector;
}

/**
 * Initialize all connectors from config
 */
async function initializeAllConnectors(
  configs: ConnectorConfig[],
  options: {
    logger?: { info: Function; warn: Function; error: Function };
  } = {}
): Promise<{ initialized: string[]; failed: string[] }> {
  const initialized: string[] = [];
  const failed: string[] = [];
  const logger = options.logger || console;

  for (const config of configs) {
    try {
      const connector = await initializeConnector(config, options);
      await connectorRegistry.register(connector, config);
      initialized.push(config.name);
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      logger.error(`Failed to initialize connector ${config.name}: ${message}`);
      failed.push(config.name);

      if (config.required) {
        throw new Error(`Required connector failed to initialize: ${config.name} - ${message}`);
      }
    }
  }

  return { initialized, failed };
}

/**
 * Shutdown all connectors
 */
async function shutdownConnectors(): Promise<void> {
  await connectorRegistry.unregisterAll();
}

// ============================================================================
// Exports
// ============================================================================

export {
  // Registry
  ConnectorRegistry,
  connectorRegistry,
  // Initialization
  initializeConnector,
  initializeAllConnectors,
  shutdownConnectors,
  createBaseConnector,
  // Retry
  withRetry,
  calculateBackoffDelay,
  // Pool
  ConnectionPool,
  // Credentials
  buildAuthHeader,
  getAuthHeaderName,
  isTokenExpired,
  // Constants
  DEFAULT_RETRY_OPTIONS,
  // Types
  type Connector,
  type ConnectorConfig,
  type Credentials,
  type CredentialType,
  type OAuthCredentials,
  type ApiKeyCredentials,
  type BasicCredentials,
  type BearerCredentials,
  type NoCredentials,
  type ConnectionState,
  type PoolEntry,
  type RetryOptions,
  type HealthCheckResult,
};
