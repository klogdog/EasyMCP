/**
 * Health Check System Template
 * Generated by EasyMCP
 * 
 * Provides Kubernetes-compatible health check endpoints:
 * - /health - Basic health status
 * - /health/ready - Readiness probe (all dependencies connected)
 * - /health/live - Liveness probe (process responsive)
 */

import * as http from 'http';

// ============================================================================
// Types
// ============================================================================

export interface HealthCheckResult {
  name: string;
  status: 'healthy' | 'unhealthy' | 'degraded';
  message?: string;
  latency?: number;
  lastCheck?: string;
}

export interface HealthStatus {
  status: 'ok' | 'degraded' | 'unhealthy';
  uptime: number;
  timestamp: string;
  version: string;
  tools: string[];
  connectors: string[];
  checks: Record<string, HealthCheckResult>;
}

export interface ReadinessStatus {
  ready: boolean;
  timestamp: string;
  checks: Record<string, boolean>;
  message?: string;
}

export interface LivenessStatus {
  alive: boolean;
  timestamp: string;
  uptime: number;
  memoryUsage: NodeJS.MemoryUsage;
}

export interface HealthCheckConfig {
  enabled: boolean;
  interval?: number;
  timeout?: number;
  unhealthyThreshold?: number;
}

// ============================================================================
// Health Check Manager
// ============================================================================

type HealthCheckFunction = () => Promise<HealthCheckResult>;

export class HealthCheckManager {
  private startTime: number;
  private version: string;
  private checks: Map<string, HealthCheckFunction> = new Map();
  private lastResults: Map<string, HealthCheckResult> = new Map();
  private checkInterval: NodeJS.Timeout | null = null;
  private config: HealthCheckConfig;
  
  constructor(version: string = '1.0.0', config: Partial<HealthCheckConfig> = {}) {
    this.startTime = Date.now();
    this.version = version;
    this.config = {
      enabled: true,
      interval: 30000, // 30 seconds
      timeout: 5000,   // 5 seconds
      unhealthyThreshold: 3,
      ...config,
    };
  }
  
  /**
   * Register a health check function
   */
  registerCheck(name: string, checkFn: HealthCheckFunction): void {
    this.checks.set(name, checkFn);
  }
  
  /**
   * Remove a health check
   */
  removeCheck(name: string): boolean {
    this.lastResults.delete(name);
    return this.checks.delete(name);
  }
  
  /**
   * Start periodic health checks
   */
  startPeriodicChecks(): void {
    if (this.checkInterval) {
      return;
    }
    
    this.checkInterval = setInterval(async () => {
      await this.runAllChecks();
    }, this.config.interval);
    
    // Run initial check
    this.runAllChecks().catch(console.error);
  }
  
  /**
   * Stop periodic health checks
   */
  stopPeriodicChecks(): void {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }
  }
  
  /**
   * Run all registered health checks
   */
  async runAllChecks(): Promise<Map<string, HealthCheckResult>> {
    const promises: Promise<void>[] = [];
    
    for (const [name, checkFn] of this.checks) {
      promises.push(
        this.runCheck(name, checkFn).then(result => {
          this.lastResults.set(name, result);
        })
      );
    }
    
    await Promise.allSettled(promises);
    return new Map(this.lastResults);
  }
  
  /**
   * Run a single health check with timeout
   */
  private async runCheck(name: string, checkFn: HealthCheckFunction): Promise<HealthCheckResult> {
    const startTime = Date.now();
    
    try {
      const result = await Promise.race([
        checkFn(),
        new Promise<HealthCheckResult>((_, reject) =>
          setTimeout(() => reject(new Error('Health check timeout')), this.config.timeout)
        ),
      ]);
      
      return {
        ...result,
        latency: Date.now() - startTime,
        lastCheck: new Date().toISOString(),
      };
    } catch (error) {
      return {
        name,
        status: 'unhealthy',
        message: error instanceof Error ? error.message : 'Unknown error',
        latency: Date.now() - startTime,
        lastCheck: new Date().toISOString(),
      };
    }
  }
  
  /**
   * Get current uptime in seconds
   */
  getUptime(): number {
    return Math.floor((Date.now() - this.startTime) / 1000);
  }
  
  /**
   * Get overall health status
   */
  async getHealthStatus(tools: string[], connectors: string[]): Promise<HealthStatus> {
    // Run all checks
    await this.runAllChecks();
    
    const checks: Record<string, HealthCheckResult> = {};
    let hasUnhealthy = false;
    let hasDegraded = false;
    
    for (const [name, result] of this.lastResults) {
      checks[name] = result;
      if (result.status === 'unhealthy') {
        hasUnhealthy = true;
      } else if (result.status === 'degraded') {
        hasDegraded = true;
      }
    }
    
    let status: 'ok' | 'degraded' | 'unhealthy';
    if (hasUnhealthy) {
      status = 'unhealthy';
    } else if (hasDegraded) {
      status = 'degraded';
    } else {
      status = 'ok';
    }
    
    return {
      status,
      uptime: this.getUptime(),
      timestamp: new Date().toISOString(),
      version: this.version,
      tools,
      connectors,
      checks,
    };
  }
  
  /**
   * Get readiness status (for Kubernetes readiness probe)
   */
  async getReadinessStatus(): Promise<ReadinessStatus> {
    await this.runAllChecks();
    
    const checks: Record<string, boolean> = {};
    let allReady = true;
    let failedCheck: string | undefined;
    
    for (const [name, result] of this.lastResults) {
      const isReady = result.status !== 'unhealthy';
      checks[name] = isReady;
      if (!isReady) {
        allReady = false;
        failedCheck = name;
      }
    }
    
    return {
      ready: allReady,
      timestamp: new Date().toISOString(),
      checks,
      message: allReady ? undefined : `Check failed: ${failedCheck}`,
    };
  }
  
  /**
   * Get liveness status (for Kubernetes liveness probe)
   */
  getLivenessStatus(): LivenessStatus {
    return {
      alive: true,
      timestamp: new Date().toISOString(),
      uptime: this.getUptime(),
      memoryUsage: process.memoryUsage(),
    };
  }
}

// ============================================================================
// Health Endpoint Handlers
// ============================================================================

export function createHealthEndpoints(
  healthManager: HealthCheckManager,
  getTools: () => string[],
  getConnectors: () => string[]
) {
  return async function handleHealthRequest(
    req: http.IncomingMessage,
    res: http.ServerResponse
  ): Promise<boolean> {
    const url = req.url || '';
    
    // Basic health check
    if (url === '/health' && req.method === 'GET') {
      try {
        const health = await healthManager.getHealthStatus(getTools(), getConnectors());
        const statusCode = health.status === 'unhealthy' ? 503 : 200;
        
        res.writeHead(statusCode, {
          'Content-Type': 'application/json',
          'Cache-Control': 'no-cache, no-store, must-revalidate',
        });
        res.end(JSON.stringify(health));
        return true;
      } catch (error) {
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Health check failed' }));
        return true;
      }
    }
    
    // Readiness probe (Kubernetes)
    if (url === '/health/ready' && req.method === 'GET') {
      try {
        const readiness = await healthManager.getReadinessStatus();
        const statusCode = readiness.ready ? 200 : 503;
        
        res.writeHead(statusCode, {
          'Content-Type': 'application/json',
          'Cache-Control': 'no-cache, no-store, must-revalidate',
        });
        res.end(JSON.stringify(readiness));
        return true;
      } catch (error) {
        res.writeHead(503, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ ready: false, error: 'Readiness check failed' }));
        return true;
      }
    }
    
    // Liveness probe (Kubernetes)
    if (url === '/health/live' && req.method === 'GET') {
      try {
        const liveness = healthManager.getLivenessStatus();
        
        res.writeHead(200, {
          'Content-Type': 'application/json',
          'Cache-Control': 'no-cache, no-store, must-revalidate',
        });
        res.end(JSON.stringify(liveness));
        return true;
      } catch (error) {
        res.writeHead(503, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ alive: false, error: 'Liveness check failed' }));
        return true;
      }
    }
    
    return false; // Not a health endpoint
  };
}

// ============================================================================
// Connector Health Check Factory
// ============================================================================

export function createConnectorHealthCheck(
  connectorName: string,
  isConnected: () => boolean
): HealthCheckFunction {
  return async (): Promise<HealthCheckResult> => {
    try {
      const connected = isConnected();
      return {
        name: `connector:${connectorName}`,
        status: connected ? 'healthy' : 'unhealthy',
        message: connected ? 'Connected' : 'Disconnected',
      };
    } catch (error) {
      return {
        name: `connector:${connectorName}`,
        status: 'unhealthy',
        message: error instanceof Error ? error.message : 'Check failed',
      };
    }
  };
}

// ============================================================================
// Exports
// ============================================================================
export default HealthCheckManager;
