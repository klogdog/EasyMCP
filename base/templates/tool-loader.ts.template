/**
 * MCP Tool Loader Template
 * Generated by EasyMCP
 * 
 * This file handles dynamic loading, registration, and invocation of MCP tools.
 * It provides input validation, lifecycle hooks, and standardized response formats.
 */

// ============================================================================
// Placeholder for Tool Definitions - Populated during code generation
// ============================================================================
{{TOOL_LIST}}

// ============================================================================
// Types
// ============================================================================

/**
 * JSON Schema definition for tool input validation
 */
interface JSONSchema {
  type?: string;
  properties?: Record<string, JSONSchema>;
  required?: string[];
  items?: JSONSchema;
  enum?: unknown[];
  minimum?: number;
  maximum?: number;
  minLength?: number;
  maxLength?: number;
  pattern?: string;
  format?: string;
  description?: string;
  default?: unknown;
  additionalProperties?: boolean | JSONSchema;
  $ref?: string;
  definitions?: Record<string, JSONSchema>;
}

/**
 * Tool definition interface
 */
interface Tool {
  /** Unique tool name */
  name: string;
  /** Human-readable description */
  description: string;
  /** JSON Schema for input validation */
  inputSchema: JSONSchema;
  /** Tool handler function */
  handler: (args: unknown) => Promise<unknown>;
  /** Optional hook called when tool is registered */
  onLoad?: () => void | Promise<void>;
  /** Optional hook called when tool is unregistered */
  onUnload?: () => void | Promise<void>;
  /** Optional timeout in milliseconds */
  timeout?: number;
  /** Optional tags for categorization */
  tags?: string[];
}

/**
 * Tool definition for dynamic loading from manifest
 */
interface ToolDefinition {
  /** Tool name from manifest */
  name: string;
  /** Path to tool module */
  path: string;
  /** Whether tool is required for server startup */
  required?: boolean;
  /** Optional configuration for the tool */
  config?: Record<string, unknown>;
}

/**
 * Standardized tool result format
 */
interface ToolResult {
  /** Whether the tool executed successfully */
  success: boolean;
  /** Result data if successful */
  result?: unknown;
  /** Error message if failed */
  error?: string;
  /** Error code for programmatic handling */
  errorCode?: string;
  /** Execution time in milliseconds */
  executionTime?: number;
}

/**
 * Validation error details
 */
interface ValidationError {
  /** Path to the invalid field */
  path: string;
  /** Error message */
  message: string;
  /** Actual value that failed validation */
  value?: unknown;
  /** Expected type or constraint */
  expected?: string;
}

/**
 * Validation result
 */
interface ValidationResult {
  /** Whether validation passed */
  valid: boolean;
  /** List of validation errors */
  errors: ValidationError[];
}

// ============================================================================
// JSON Schema Validator (Simplified AJV-compatible implementation)
// ============================================================================

/**
 * Simple JSON Schema validator
 * For production, consider using AJV library
 */
class SchemaValidator {
  /**
   * Validate data against a JSON Schema
   */
  validate(schema: JSONSchema, data: unknown): ValidationResult {
    const errors: ValidationError[] = [];
    this.validateValue(schema, data, '', errors);
    return {
      valid: errors.length === 0,
      errors,
    };
  }

  private validateValue(
    schema: JSONSchema,
    data: unknown,
    path: string,
    errors: ValidationError[]
  ): void {
    // Handle null/undefined
    if (data === null || data === undefined) {
      if (schema.type && schema.type !== 'null') {
        // Check if required - allow undefined for optional fields
        if (data === null) {
          errors.push({
            path: path || 'root',
            message: `Expected ${schema.type}, got null`,
            value: data,
            expected: schema.type,
          });
        }
      }
      return;
    }

    // Type validation
    if (schema.type) {
      const actualType = this.getType(data);
      if (schema.type !== actualType) {
        // Handle integer as number
        if (!(schema.type === 'integer' && actualType === 'number' && Number.isInteger(data as number))) {
          errors.push({
            path: path || 'root',
            message: `Expected ${schema.type}, got ${actualType}`,
            value: data,
            expected: schema.type,
          });
          return;
        }
      }
    }

    // Enum validation
    if (schema.enum) {
      if (!schema.enum.includes(data)) {
        errors.push({
          path: path || 'root',
          message: `Value must be one of: ${schema.enum.join(', ')}`,
          value: data,
          expected: `one of [${schema.enum.join(', ')}]`,
        });
      }
    }

    // String validations
    if (typeof data === 'string') {
      if (schema.minLength !== undefined && data.length < schema.minLength) {
        errors.push({
          path: path || 'root',
          message: `String must be at least ${schema.minLength} characters`,
          value: data,
          expected: `minLength: ${schema.minLength}`,
        });
      }
      if (schema.maxLength !== undefined && data.length > schema.maxLength) {
        errors.push({
          path: path || 'root',
          message: `String must be at most ${schema.maxLength} characters`,
          value: data,
          expected: `maxLength: ${schema.maxLength}`,
        });
      }
      if (schema.pattern) {
        const regex = new RegExp(schema.pattern);
        if (!regex.test(data)) {
          errors.push({
            path: path || 'root',
            message: `String must match pattern: ${schema.pattern}`,
            value: data,
            expected: `pattern: ${schema.pattern}`,
          });
        }
      }
    }

    // Number validations
    if (typeof data === 'number') {
      if (schema.minimum !== undefined && data < schema.minimum) {
        errors.push({
          path: path || 'root',
          message: `Number must be >= ${schema.minimum}`,
          value: data,
          expected: `minimum: ${schema.minimum}`,
        });
      }
      if (schema.maximum !== undefined && data > schema.maximum) {
        errors.push({
          path: path || 'root',
          message: `Number must be <= ${schema.maximum}`,
          value: data,
          expected: `maximum: ${schema.maximum}`,
        });
      }
    }

    // Object validation
    if (typeof data === 'object' && !Array.isArray(data) && data !== null) {
      const obj = data as Record<string, unknown>;

      // Check required properties
      if (schema.required) {
        for (const prop of schema.required) {
          if (!(prop in obj)) {
            errors.push({
              path: path ? `${path}.${prop}` : prop,
              message: `Missing required property: ${prop}`,
              expected: 'required',
            });
          }
        }
      }

      // Validate properties
      if (schema.properties) {
        for (const [key, propSchema] of Object.entries(schema.properties)) {
          if (key in obj) {
            this.validateValue(
              propSchema,
              obj[key],
              path ? `${path}.${key}` : key,
              errors
            );
          }
        }
      }

      // Check additional properties
      if (schema.additionalProperties === false) {
        const allowedProps = Object.keys(schema.properties || {});
        for (const key of Object.keys(obj)) {
          if (!allowedProps.includes(key)) {
            errors.push({
              path: path ? `${path}.${key}` : key,
              message: `Additional property not allowed: ${key}`,
              value: obj[key],
            });
          }
        }
      }
    }

    // Array validation
    if (Array.isArray(data)) {
      if (schema.items) {
        data.forEach((item, index) => {
          this.validateValue(
            schema.items!,
            item,
            path ? `${path}[${index}]` : `[${index}]`,
            errors
          );
        });
      }
    }
  }

  private getType(value: unknown): string {
    if (value === null) return 'null';
    if (Array.isArray(value)) return 'array';
    return typeof value;
  }
}

// ============================================================================
// Tool Registry
// ============================================================================

/**
 * Registry for managing MCP tools
 */
class ToolRegistry {
  private tools = new Map<string, Tool>();
  private validator = new SchemaValidator();
  private loadOrder: string[] = [];

  /**
   * Register a tool with the registry
   */
  async register(tool: Tool): Promise<void> {
    if (!tool.name) {
      throw new Error('Tool must have a name');
    }

    if (this.tools.has(tool.name)) {
      throw new Error(`Tool already registered: ${tool.name}`);
    }

    // Call onLoad hook if provided
    if (tool.onLoad) {
      try {
        await Promise.resolve(tool.onLoad());
      } catch (error) {
        throw new Error(
          `Failed to initialize tool ${tool.name}: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    }

    this.tools.set(tool.name, tool);
    this.loadOrder.push(tool.name);
  }

  /**
   * Get a tool by name
   */
  get(name: string): Tool | undefined {
    return this.tools.get(name);
  }

  /**
   * Check if a tool exists
   */
  has(name: string): boolean {
    return this.tools.has(name);
  }

  /**
   * List all registered tools
   */
  list(): Tool[] {
    return Array.from(this.tools.values());
  }

  /**
   * Get tool names
   */
  names(): string[] {
    return Array.from(this.tools.keys());
  }

  /**
   * Unregister a tool
   */
  async unregister(name: string): Promise<void> {
    const tool = this.tools.get(name);
    if (!tool) {
      throw new Error(`Tool not found: ${name}`);
    }

    // Call onUnload hook if provided
    if (tool.onUnload) {
      try {
        await Promise.resolve(tool.onUnload());
      } catch (error) {
        console.warn(
          `Warning: onUnload hook failed for ${name}: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    }

    this.tools.delete(name);
    this.loadOrder = this.loadOrder.filter(n => n !== name);
  }

  /**
   * Unregister all tools (in reverse order)
   */
  async unregisterAll(): Promise<void> {
    // Unload in reverse order of loading
    const order = [...this.loadOrder].reverse();
    for (const name of order) {
      try {
        await this.unregister(name);
      } catch (error) {
        console.warn(`Warning: Failed to unregister ${name}: ${error}`);
      }
    }
  }

  /**
   * Validate input against a tool's schema
   */
  validateInput(toolName: string, args: unknown): ValidationResult {
    const tool = this.tools.get(toolName);
    if (!tool) {
      return {
        valid: false,
        errors: [{ path: '', message: `Tool not found: ${toolName}` }],
      };
    }

    return this.validator.validate(tool.inputSchema, args);
  }

  /**
   * Get tool count
   */
  get count(): number {
    return this.tools.size;
  }
}

// ============================================================================
// Global Registry Instance
// ============================================================================

const toolRegistry = new ToolRegistry();

// ============================================================================
// Tool Loading
// ============================================================================

/**
 * Load tools from a manifest
 */
async function loadTools(
  manifest: { tools: ToolDefinition[] },
  options: { logger?: { info: Function; warn: Function; error: Function } } = {}
): Promise<{ loaded: string[]; failed: string[] }> {
  const loaded: string[] = [];
  const failed: string[] = [];
  const logger = options.logger || console;

  for (const toolDef of manifest.tools) {
    try {
      logger.info(`Loading tool: ${toolDef.name} from ${toolDef.path}`);

      // Dynamic import
      const module = await import(toolDef.path);

      // Extract the tool (default export or named export matching tool name)
      const tool: Tool = module.default || module[toolDef.name];

      if (!tool) {
        throw new Error(`No default export or named export '${toolDef.name}' found`);
      }

      // Apply config if provided
      if (toolDef.config && typeof (tool as any).configure === 'function') {
        (tool as any).configure(toolDef.config);
      }

      // Register the tool
      await toolRegistry.register(tool);
      loaded.push(toolDef.name);
      logger.info(`Loaded tool: ${toolDef.name}`);
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      logger.error(`Failed to load tool ${toolDef.name}: ${message}`);
      failed.push(toolDef.name);

      // If tool is required, throw
      if (toolDef.required) {
        throw new Error(`Required tool failed to load: ${toolDef.name} - ${message}`);
      }
    }
  }

  return { loaded, failed };
}

/**
 * Unload all tools (for shutdown)
 */
async function unloadTools(): Promise<void> {
  await toolRegistry.unregisterAll();
}

// ============================================================================
// Tool Invocation
// ============================================================================

/**
 * Invoke a tool by name with arguments
 */
async function invokeTool(
  name: string,
  args: unknown,
  options: {
    validateInput?: boolean;
    timeout?: number;
    logger?: { debug: Function; error: Function };
  } = {}
): Promise<ToolResult> {
  const startTime = Date.now();
  const logger = options.logger;
  const validateInput = options.validateInput ?? true;

  try {
    // Get the tool
    const tool = toolRegistry.get(name);
    if (!tool) {
      return {
        success: false,
        error: `Tool not found: ${name}`,
        errorCode: 'TOOL_NOT_FOUND',
        executionTime: Date.now() - startTime,
      };
    }

    // Validate input if enabled
    if (validateInput) {
      const validation = toolRegistry.validateInput(name, args);
      if (!validation.valid) {
        const errorMessages = validation.errors.map(e => `${e.path}: ${e.message}`).join('; ');
        return {
          success: false,
          error: `Input validation failed: ${errorMessages}`,
          errorCode: 'VALIDATION_ERROR',
          executionTime: Date.now() - startTime,
        };
      }
    }

    logger?.debug(`Invoking tool: ${name}`);

    // Determine timeout
    const timeout = options.timeout ?? tool.timeout ?? 30000;

    // Execute with timeout
    const result = await executeWithTimeout(
      () => tool.handler(args),
      timeout,
      `Tool ${name} timed out after ${timeout}ms`
    );

    const executionTime = Date.now() - startTime;
    logger?.debug(`Tool ${name} completed in ${executionTime}ms`);

    return {
      success: true,
      result,
      executionTime,
    };
  } catch (error) {
    const executionTime = Date.now() - startTime;
    const message = error instanceof Error ? error.message : String(error);

    logger?.error(`Tool ${name} failed: ${message}`);

    // Determine error code
    let errorCode = 'TOOL_ERROR';
    if (message.includes('timed out')) {
      errorCode = 'TIMEOUT';
    }

    return {
      success: false,
      error: message,
      errorCode,
      executionTime,
    };
  }
}

/**
 * Execute a function with a timeout
 */
async function executeWithTimeout<T>(
  fn: () => Promise<T>,
  timeoutMs: number,
  timeoutMessage: string
): Promise<T> {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => {
      reject(new Error(timeoutMessage));
    }, timeoutMs);

    fn()
      .then(result => {
        clearTimeout(timer);
        resolve(result);
      })
      .catch(error => {
        clearTimeout(timer);
        reject(error);
      });
  });
}

// ============================================================================
// Batch Tool Invocation
// ============================================================================

/**
 * Invoke multiple tools in parallel
 */
async function invokeToolsBatch(
  calls: Array<{ name: string; args: unknown }>,
  options: {
    validateInput?: boolean;
    timeout?: number;
    logger?: { debug: Function; error: Function };
    continueOnError?: boolean;
  } = {}
): Promise<ToolResult[]> {
  const continueOnError = options.continueOnError ?? true;

  if (continueOnError) {
    // Execute all and collect results
    return Promise.all(
      calls.map(call => invokeTool(call.name, call.args, options))
    );
  } else {
    // Stop on first error
    const results: ToolResult[] = [];
    for (const call of calls) {
      const result = await invokeTool(call.name, call.args, options);
      results.push(result);
      if (!result.success) {
        break;
      }
    }
    return results;
  }
}

// ============================================================================
// Tool Information
// ============================================================================

/**
 * Get tool information for MCP protocol
 */
function getToolInfo(name: string): {
  name: string;
  description: string;
  inputSchema: JSONSchema;
} | null {
  const tool = toolRegistry.get(name);
  if (!tool) return null;

  return {
    name: tool.name,
    description: tool.description,
    inputSchema: tool.inputSchema,
  };
}

/**
 * Get all tools info for MCP tools/list
 */
function getAllToolsInfo(): Array<{
  name: string;
  description: string;
  inputSchema: JSONSchema;
}> {
  return toolRegistry.list().map(tool => ({
    name: tool.name,
    description: tool.description,
    inputSchema: tool.inputSchema,
  }));
}

// ============================================================================
// Exports
// ============================================================================

export {
  // Registry
  ToolRegistry,
  toolRegistry,
  // Loading
  loadTools,
  unloadTools,
  // Invocation
  invokeTool,
  invokeToolsBatch,
  executeWithTimeout,
  // Information
  getToolInfo,
  getAllToolsInfo,
  // Validation
  SchemaValidator,
  // Types
  type Tool,
  type ToolDefinition,
  type ToolResult,
  type ValidationError,
  type ValidationResult,
  type JSONSchema,
};
