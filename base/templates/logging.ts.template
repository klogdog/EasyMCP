/**
 * Structured Logging System Template
 * Generated by EasyMCP
 * 
 * Provides pino-compatible structured JSON logging with:
 * - Request ID tracking
 * - Correlation IDs
 * - Log levels
 * - File and console output
 */

import * as fs from 'fs';

// ============================================================================
// Types
// ============================================================================

export type LogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'fatal';

export interface LogContext {
  requestId?: string;
  correlationId?: string;
  traceId?: string;
  spanId?: string;
  [key: string]: unknown;
}

export interface LogEntry {
  level: number;
  time: number;
  pid: number;
  hostname: string;
  msg: string;
  requestId?: string;
  correlationId?: string;
  traceId?: string;
  spanId?: string;
  [key: string]: unknown;
}

export interface LoggerConfig {
  level?: LogLevel;
  format?: 'json' | 'pretty';
  file?: string;
  name?: string;
  redact?: string[];
  timestamp?: boolean;
}

// ============================================================================
// Log Level Mapping
// ============================================================================

const LOG_LEVELS: Record<LogLevel, number> = {
  trace: 10,
  debug: 20,
  info: 30,
  warn: 40,
  error: 50,
  fatal: 60,
};

const LEVEL_NAMES: Record<number, LogLevel> = {
  10: 'trace',
  20: 'debug',
  30: 'info',
  40: 'warn',
  50: 'error',
  60: 'fatal',
};

const LEVEL_COLORS: Record<LogLevel, string> = {
  trace: '\x1b[37m',    // White
  debug: '\x1b[36m',    // Cyan
  info: '\x1b[32m',     // Green
  warn: '\x1b[33m',     // Yellow
  error: '\x1b[31m',    // Red
  fatal: '\x1b[35m',    // Magenta
};

const RESET = '\x1b[0m';

// ============================================================================
// Redaction
// ============================================================================

function redactValue(value: unknown, redactPaths: string[]): unknown {
  if (!value || typeof value !== 'object') {
    return value;
  }
  
  const result = { ...(value as Record<string, unknown>) };
  
  for (const path of redactPaths) {
    const parts = path.split('.');
    let current: Record<string, unknown> = result;
    
    for (let i = 0; i < parts.length - 1; i++) {
      if (current[parts[i]] && typeof current[parts[i]] === 'object') {
        current = current[parts[i]] as Record<string, unknown>;
      } else {
        break;
      }
    }
    
    const finalKey = parts[parts.length - 1];
    if (finalKey in current) {
      current[finalKey] = '[REDACTED]';
    }
  }
  
  return result;
}

// ============================================================================
// Logger Class
// ============================================================================

export class StructuredLogger {
  private level: number;
  private format: 'json' | 'pretty';
  private fileStream: fs.WriteStream | null = null;
  private name: string;
  private redactPaths: string[];
  private includeTimestamp: boolean;
  private hostname: string;
  private pid: number;
  private bindings: LogContext = {};
  
  constructor(config: LoggerConfig = {}) {
    this.level = LOG_LEVELS[config.level || 'info'];
    this.format = config.format || 'json';
    this.name = config.name || 'mcp-server';
    this.redactPaths = config.redact || ['password', 'token', 'secret', 'apiKey', 'authorization'];
    this.includeTimestamp = config.timestamp !== false;
    this.hostname = process.env.HOSTNAME || 'localhost';
    this.pid = process.pid;
    
    if (config.file) {
      this.fileStream = fs.createWriteStream(config.file, { flags: 'a' });
    }
  }
  
  /**
   * Create a child logger with additional bindings
   */
  child(bindings: LogContext): StructuredLogger {
    const child = Object.create(this) as StructuredLogger;
    child.bindings = { ...this.bindings, ...bindings };
    return child;
  }
  
  /**
   * Check if a level is enabled
   */
  isLevelEnabled(level: LogLevel): boolean {
    return LOG_LEVELS[level] >= this.level;
  }
  
  /**
   * Internal log method
   */
  private log(level: LogLevel, msgOrContext: string | LogContext, msg?: string): void {
    const levelNum = LOG_LEVELS[level];
    if (levelNum < this.level) {
      return;
    }
    
    let message: string;
    let context: LogContext = {};
    
    if (typeof msgOrContext === 'string') {
      message = msgOrContext;
    } else {
      context = msgOrContext;
      message = msg || '';
    }
    
    // Merge bindings and context
    const mergedContext = { ...this.bindings, ...context };
    
    // Redact sensitive values
    const redactedContext = redactValue(mergedContext, this.redactPaths) as LogContext;
    
    // Build log entry
    const entry: LogEntry = {
      level: levelNum,
      time: this.includeTimestamp ? Date.now() : 0,
      pid: this.pid,
      hostname: this.hostname,
      name: this.name,
      msg: message,
      ...redactedContext,
    };
    
    // Format and output
    const formatted = this.formatEntry(entry, level);
    this.write(formatted);
  }
  
  /**
   * Format a log entry
   */
  private formatEntry(entry: LogEntry, level: LogLevel): string {
    if (this.format === 'json') {
      return JSON.stringify(entry);
    }
    
    // Pretty format
    const timestamp = entry.time ? new Date(entry.time).toISOString() : '';
    const color = LEVEL_COLORS[level];
    const levelStr = level.toUpperCase().padEnd(5);
    
    let line = `${timestamp} ${color}${levelStr}${RESET}`;
    
    if (entry.requestId) {
      line += ` [${entry.requestId.substring(0, 8)}]`;
    }
    
    line += `: ${entry.msg}`;
    
    // Add context fields
    const contextFields = { ...entry };
    delete contextFields.level;
    delete contextFields.time;
    delete contextFields.pid;
    delete contextFields.hostname;
    delete contextFields.name;
    delete contextFields.msg;
    delete contextFields.requestId;
    delete contextFields.correlationId;
    
    if (Object.keys(contextFields).length > 0) {
      line += ` ${JSON.stringify(contextFields)}`;
    }
    
    return line;
  }
  
  /**
   * Write to output
   */
  private write(formatted: string): void {
    console.log(formatted);
    
    if (this.fileStream) {
      this.fileStream.write(formatted + '\n');
    }
  }
  
  // Log level methods
  trace(msgOrContext: string | LogContext, msg?: string): void {
    this.log('trace', msgOrContext, msg);
  }
  
  debug(msgOrContext: string | LogContext, msg?: string): void {
    this.log('debug', msgOrContext, msg);
  }
  
  info(msgOrContext: string | LogContext, msg?: string): void {
    this.log('info', msgOrContext, msg);
  }
  
  warn(msgOrContext: string | LogContext, msg?: string): void {
    this.log('warn', msgOrContext, msg);
  }
  
  error(msgOrContext: string | LogContext, msg?: string): void {
    this.log('error', msgOrContext, msg);
  }
  
  fatal(msgOrContext: string | LogContext, msg?: string): void {
    this.log('fatal', msgOrContext, msg);
  }
  
  /**
   * Flush and close file stream
   */
  async flush(): Promise<void> {
    if (this.fileStream) {
      return new Promise((resolve) => {
        this.fileStream!.end(() => resolve());
      });
    }
  }
  
  /**
   * Close the logger
   */
  close(): void {
    if (this.fileStream) {
      this.fileStream.end();
      this.fileStream = null;
    }
  }
}

// ============================================================================
// Request Logger Middleware
// ============================================================================

export interface RequestLoggerOptions {
  includeHeaders?: boolean;
  includeBody?: boolean;
  excludePaths?: string[];
}

export function createRequestLogger(
  logger: StructuredLogger,
  options: RequestLoggerOptions = {}
) {
  const excludePaths = new Set(options.excludePaths || ['/health', '/health/ready', '/health/live', '/metrics']);
  
  return function logRequest(
    requestId: string,
    method: string,
    url: string,
    statusCode: number,
    duration: number,
    headers?: Record<string, string | string[] | undefined>,
    responseSize?: number
  ): void {
    if (excludePaths.has(url)) {
      return;
    }
    
    const context: LogContext = {
      requestId,
      method,
      url,
      statusCode,
      duration,
      responseSize,
    };
    
    if (options.includeHeaders && headers) {
      context.headers = headers;
    }
    
    const level = statusCode >= 500 ? 'error' : statusCode >= 400 ? 'warn' : 'info';
    
    if (level === 'error') {
      logger.error(context, `${method} ${url} ${statusCode} ${duration}ms`);
    } else if (level === 'warn') {
      logger.warn(context, `${method} ${url} ${statusCode} ${duration}ms`);
    } else {
      logger.info(context, `${method} ${url} ${statusCode} ${duration}ms`);
    }
  };
}

// ============================================================================
// Exports
// ============================================================================
export default StructuredLogger;
