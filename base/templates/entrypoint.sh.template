#!/bin/bash
#
# MCP Server Entrypoint Script
# Generated by EasyMCP
#
# This script handles container/server startup, including:
# - Configuration file validation
# - Environment variable loading
# - Required variable verification
# - Signal handling for graceful shutdown
# - Dev/prod mode switching
#

# ============================================================================
# Strict Mode Settings
# ============================================================================
set -e          # Exit immediately if a command exits with non-zero status
set -u          # Treat unset variables as an error
set -o pipefail # Return value of pipeline is the last command to fail

# ============================================================================
# Color Constants for Logging
# ============================================================================
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[0;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# ============================================================================
# Global Variables
# ============================================================================
PID=""
MODE="${1:-prod}"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
STARTUP_TIME=$(date +%s)

# ============================================================================
# Logging Functions
# ============================================================================

log_info() {
    echo -e "${BLUE}[INFO]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $*"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $*"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $*" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $*" >&2
}

log_debug() {
    if [ "${LOG_LEVEL:-info}" = "debug" ]; then
        echo -e "[DEBUG] $(date '+%Y-%m-%d %H:%M:%S') - $*"
    fi
}

# ============================================================================
# Banner Display
# ============================================================================

show_banner() {
    cat << 'EOF'
  _____ ____ _   _     __  __ ___ ____ 
 |  ___/ ___| | | |   |  \/  |_ _/ ___|
 | |_ | |   | |_| |   | |\/| || |\___ \
 |  _|| |___|  _  |   | |  | || | ___) |
 |_|   \____|_| |_|   |_|  |_|___|____/
                                        
 MCP Server - {{SERVER_NAME}}
 Version: {{SERVER_VERSION}}
EOF
    echo ""
}

# ============================================================================
# Environment Variable Loading
# ============================================================================

load_env_file() {
    local env_file="${1:-.env}"
    
    if [ -f "$env_file" ]; then
        log_info "Loading environment from $env_file"
        
        # Export variables, ignoring comments and empty lines
        while IFS= read -r line || [ -n "$line" ]; do
            # Skip comments and empty lines
            if [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]]; then
                continue
            fi
            
            # Skip lines without = sign
            if [[ ! "$line" =~ = ]]; then
                continue
            fi
            
            # Trim whitespace and export
            local key="${line%%=*}"
            local value="${line#*=}"
            
            # Remove leading/trailing quotes from value
            value="${value%\"}"
            value="${value#\"}"
            value="${value%\'}"
            value="${value#\'}"
            
            # Only export if key is valid
            if [[ "$key" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then
                export "$key=$value"
                log_debug "Exported: $key"
            fi
        done < "$env_file"
        
        log_success "Environment loaded from $env_file"
    else
        log_debug "No $env_file file found, skipping"
    fi
}

# ============================================================================
# Configuration Validation
# ============================================================================

validate_config_file() {
    local config_path="${MCP_CONFIG_PATH:-}"
    
    if [ -z "$config_path" ]; then
        log_warning "MCP_CONFIG_PATH not set, using default configuration"
        return 0
    fi
    
    log_info "Validating configuration file: $config_path"
    
    # Check if file exists
    if [ ! -f "$config_path" ]; then
        log_error "Configuration file not found: $config_path"
        return 1
    fi
    
    # Check file is readable
    if [ ! -r "$config_path" ]; then
        log_error "Configuration file not readable: $config_path"
        return 1
    fi
    
    # Validate YAML syntax using Node.js
    if ! node -e "
        const fs = require('fs');
        const yaml = require('yaml');
        try {
            const content = fs.readFileSync('$config_path', 'utf8');
            yaml.parse(content);
            console.log('YAML syntax valid');
        } catch (e) {
            console.error('YAML parsing error:', e.message);
            process.exit(1);
        }
    " 2>&1; then
        log_error "Configuration file has invalid YAML syntax"
        return 1
    fi
    
    log_success "Configuration file validated successfully"
    return 0
}

validate_config_schema() {
    local config_path="${MCP_CONFIG_PATH:-}"
    
    if [ -z "$config_path" ] || [ ! -f "$config_path" ]; then
        return 0
    fi
    
    log_info "Validating configuration schema..."
    
    # Validate against expected schema using Node.js
    if ! node -e "
        const fs = require('fs');
        const yaml = require('yaml');
        
        const content = fs.readFileSync('$config_path', 'utf8');
        const config = yaml.parse(content);
        
        // Check required fields
        const required = ['server', 'tools'];
        for (const field of required) {
            if (!(field in config)) {
                console.error('Missing required field:', field);
                process.exit(1);
            }
        }
        
        // Validate server section
        if (config.server) {
            if (!config.server.port || typeof config.server.port !== 'number') {
                console.error('Server port must be a number');
                process.exit(1);
            }
        }
        
        console.log('Schema validation passed');
    " 2>&1; then
        log_error "Configuration schema validation failed"
        return 1
    fi
    
    log_success "Configuration schema validated"
    return 0
}

# ============================================================================
# Required Variables Check
# ============================================================================

check_required_variables() {
    log_info "Checking required environment variables..."
    
    local missing_vars=()
    
    # List of required variables - add more as needed
    # Format: VARIABLE_NAME:description
    local required_vars=(
        {{REQUIRED_ENV_VARS}}
    )
    
    for var_def in "${required_vars[@]}"; do
        if [ -n "$var_def" ]; then
            local var_name="${var_def%%:*}"
            local var_desc="${var_def#*:}"
            
            if [ -z "${!var_name:-}" ]; then
                missing_vars+=("$var_name ($var_desc)")
            fi
        fi
    done
    
    if [ ${#missing_vars[@]} -gt 0 ]; then
        log_error "Missing required environment variables:"
        for var in "${missing_vars[@]}"; do
            log_error "  - $var"
        done
        return 1
    fi
    
    log_success "All required environment variables are set"
    return 0
}

# ============================================================================
# Signal Handling
# ============================================================================

setup_signal_handlers() {
    log_info "Setting up signal handlers..."
    
    # Handle SIGTERM (Docker stop)
    trap 'handle_sigterm' SIGTERM
    
    # Handle SIGINT (Ctrl+C)
    trap 'handle_sigint' SIGINT
    
    # Handle SIGQUIT
    trap 'handle_sigquit' SIGQUIT
    
    # Handle SIGHUP (reload config)
    trap 'handle_sighup' SIGHUP
    
    log_debug "Signal handlers configured"
}

handle_sigterm() {
    log_info "Received SIGTERM, initiating graceful shutdown..."
    
    if [ -n "$PID" ]; then
        log_info "Sending SIGTERM to server process (PID: $PID)"
        kill -TERM "$PID" 2>/dev/null || true
        
        # Wait for process to terminate
        local timeout=30
        local count=0
        while kill -0 "$PID" 2>/dev/null && [ $count -lt $timeout ]; do
            sleep 1
            count=$((count + 1))
        done
        
        # Force kill if still running
        if kill -0 "$PID" 2>/dev/null; then
            log_warning "Process didn't terminate gracefully, sending SIGKILL"
            kill -KILL "$PID" 2>/dev/null || true
        fi
    fi
    
    log_info "Shutdown complete"
    exit 0
}

handle_sigint() {
    log_info "Received SIGINT, stopping server..."
    
    if [ -n "$PID" ]; then
        kill -INT "$PID" 2>/dev/null || true
        wait "$PID" 2>/dev/null || true
    fi
    
    exit 130
}

handle_sigquit() {
    log_info "Received SIGQUIT, dumping state and stopping..."
    
    if [ -n "$PID" ]; then
        kill -QUIT "$PID" 2>/dev/null || true
        wait "$PID" 2>/dev/null || true
    fi
    
    exit 131
}

handle_sighup() {
    log_info "Received SIGHUP, reloading configuration..."
    
    # Validate new config before applying
    if validate_config_file && validate_config_schema; then
        log_info "Configuration valid, signaling server to reload"
        if [ -n "$PID" ]; then
            kill -HUP "$PID" 2>/dev/null || true
        fi
    else
        log_error "Configuration invalid, reload aborted"
    fi
}

# ============================================================================
# Run Mode Configuration
# ============================================================================

configure_run_mode() {
    log_info "Configuring run mode: $MODE"
    
    case "$MODE" in
        dev|development)
            export NODE_ENV=development
            export LOG_LEVEL=debug
            export LOG_FORMAT=pretty
            log_info "Development mode enabled - verbose logging active"
            ;;
        prod|production)
            export NODE_ENV=production
            export LOG_LEVEL=${LOG_LEVEL:-info}
            export LOG_FORMAT=json
            log_info "Production mode enabled"
            ;;
        test|testing)
            export NODE_ENV=test
            export LOG_LEVEL=debug
            export LOG_FORMAT=pretty
            log_info "Test mode enabled"
            ;;
        *)
            log_warning "Unknown mode '$MODE', defaulting to production"
            export NODE_ENV=production
            export LOG_LEVEL=info
            export LOG_FORMAT=json
            ;;
    esac
}

# ============================================================================
# Health Check Preparation
# ============================================================================

wait_for_dependencies() {
    log_info "Checking service dependencies..."
    
    # Wait for database if DATABASE_URL is set
    if [ -n "${DATABASE_URL:-}" ]; then
        log_info "Waiting for database..."
        local max_attempts=30
        local attempt=1
        
        while [ $attempt -le $max_attempts ]; do
            if node -e "
                const url = process.env.DATABASE_URL;
                // Basic connectivity check
                console.log('Database URL configured');
                process.exit(0);
            " 2>&1; then
                log_success "Database ready"
                break
            fi
            
            log_debug "Database not ready, attempt $attempt/$max_attempts"
            sleep 2
            attempt=$((attempt + 1))
        done
        
        if [ $attempt -gt $max_attempts ]; then
            log_warning "Database may not be ready, continuing anyway"
        fi
    fi
    
    # Wait for Redis if REDIS_URL is set
    if [ -n "${REDIS_URL:-}" ]; then
        log_info "Waiting for Redis..."
        # Similar check for Redis...
    fi
    
    log_success "Dependency checks complete"
}

# ============================================================================
# Startup Information
# ============================================================================

print_startup_info() {
    log_info "=================================="
    log_info "Starting MCP Server"
    log_info "=================================="
    log_info "Mode:        $MODE"
    log_info "Node ENV:    ${NODE_ENV:-not set}"
    log_info "Log Level:   ${LOG_LEVEL:-info}"
    log_info "Config Path: ${MCP_CONFIG_PATH:-not set}"
    log_info "Server Port: ${PORT:-{{DEFAULT_PORT}}}"
    log_info "Work Dir:    $SCRIPT_DIR"
    log_info "=================================="
    
    # List loaded tools if available
    if [ -n "${MCP_CONFIG_PATH:-}" ] && [ -f "$MCP_CONFIG_PATH" ]; then
        log_info "Configured tools:"
        node -e "
            const fs = require('fs');
            const yaml = require('yaml');
            try {
                const config = yaml.parse(fs.readFileSync('$MCP_CONFIG_PATH', 'utf8'));
                if (config.tools) {
                    Object.keys(config.tools).forEach(t => console.log('  - ' + t));
                }
            } catch (e) {}
        " 2>/dev/null || true
        
        log_info "Configured connectors:"
        node -e "
            const fs = require('fs');
            const yaml = require('yaml');
            try {
                const config = yaml.parse(fs.readFileSync('$MCP_CONFIG_PATH', 'utf8'));
                if (config.connectors) {
                    Object.keys(config.connectors).forEach(c => console.log('  - ' + c));
                }
            } catch (e) {}
        " 2>/dev/null || true
    fi
    
    log_info "=================================="
}

# ============================================================================
# Pre-Start Hooks
# ============================================================================

run_pre_start_hooks() {
    log_info "Running pre-start hooks..."
    
    # Run database migrations if enabled
    if [ "${RUN_MIGRATIONS:-false}" = "true" ]; then
        log_info "Running database migrations..."
        if [ -f "node_modules/.bin/prisma" ]; then
            npx prisma migrate deploy || log_warning "Migration failed, continuing..."
        fi
    fi
    
    # Run custom pre-start script if exists
    if [ -f "./pre-start.sh" ]; then
        log_info "Executing pre-start.sh..."
        bash ./pre-start.sh || log_warning "pre-start.sh failed, continuing..."
    fi
    
    log_success "Pre-start hooks complete"
}

# ============================================================================
# Server Start Functions
# ============================================================================

start_server_foreground() {
    log_info "Starting server in foreground..."
    
    # Execute node, replacing this shell process
    exec node server.js "$@"
}

start_server_background() {
    log_info "Starting server in background..."
    
    # Start node in background
    node server.js "$@" &
    PID=$!
    
    log_info "Server started with PID: $PID"
    
    # Wait for process
    wait $PID
    local exit_code=$?
    
    log_info "Server exited with code: $exit_code"
    exit $exit_code
}

# ============================================================================
# Healthcheck Function (for Docker HEALTHCHECK)
# ============================================================================

run_healthcheck() {
    local port="${PORT:-{{DEFAULT_PORT}}}"
    local health_url="http://localhost:$port/health"
    
    if command -v curl &> /dev/null; then
        curl --fail --silent --max-time 5 "$health_url" > /dev/null
    elif command -v wget &> /dev/null; then
        wget --quiet --spider --timeout=5 "$health_url"
    else
        # Fallback to Node.js
        node -e "
            const http = require('http');
            const req = http.get('$health_url', res => {
                process.exit(res.statusCode === 200 ? 0 : 1);
            });
            req.on('error', () => process.exit(1));
            req.setTimeout(5000, () => {
                req.abort();
                process.exit(1);
            });
        "
    fi
}

# ============================================================================
# Main Entry Point
# ============================================================================

main() {
    # Parse arguments
    case "${1:-}" in
        healthcheck|health)
            run_healthcheck
            exit $?
            ;;
        version|--version|-v)
            echo "MCP Server {{SERVER_VERSION}}"
            exit 0
            ;;
        help|--help|-h)
            echo "Usage: entrypoint.sh [mode] [options]"
            echo ""
            echo "Modes:"
            echo "  dev, development  Run in development mode with verbose logging"
            echo "  prod, production  Run in production mode (default)"
            echo "  test, testing     Run in test mode"
            echo ""
            echo "Commands:"
            echo "  healthcheck       Run health check and exit"
            echo "  version           Show version and exit"
            echo "  help              Show this help message"
            exit 0
            ;;
    esac
    
    # Show startup banner
    show_banner
    
    # Load environment variables
    load_env_file ".env"
    load_env_file ".env.local"
    load_env_file ".env.$MODE"
    
    # Configure run mode
    configure_run_mode
    
    # Validate configuration
    if ! validate_config_file; then
        log_error "Configuration validation failed"
        exit 1
    fi
    
    if ! validate_config_schema; then
        log_error "Configuration schema validation failed"
        exit 1
    fi
    
    # Check required variables
    if ! check_required_variables; then
        log_error "Required variables check failed"
        exit 1
    fi
    
    # Wait for dependencies
    wait_for_dependencies
    
    # Setup signal handlers
    setup_signal_handlers
    
    # Print startup info
    print_startup_info
    
    # Run pre-start hooks
    run_pre_start_hooks
    
    # Calculate startup time
    local end_time=$(date +%s)
    local duration=$((end_time - STARTUP_TIME))
    log_success "Startup complete in ${duration}s, launching server..."
    
    # Start the server
    # Use exec to replace this process with node (allows proper signal handling)
    shift 2>/dev/null || true  # Remove mode argument if present
    start_server_foreground "$@"
}

# ============================================================================
# Script Execution
# ============================================================================

main "$@"
