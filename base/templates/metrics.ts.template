/**
 * Prometheus Metrics System Template
 * Generated by EasyMCP
 * 
 * Provides Prometheus-compatible metrics collection and exposition:
 * - Request counters
 * - Tool invocation metrics
 * - Connector status gauges
 * - Latency histograms
 */

import * as http from 'http';

// ============================================================================
// Types
// ============================================================================

export interface MetricLabels {
  [key: string]: string;
}

export interface CounterValue {
  labels: MetricLabels;
  value: number;
}

export interface GaugeValue {
  labels: MetricLabels;
  value: number;
}

export interface HistogramValue {
  labels: MetricLabels;
  sum: number;
  count: number;
  buckets: Record<number, number>;
}

export interface MetricConfig {
  enabled: boolean;
  prefix?: string;
  defaultLabels?: MetricLabels;
  histogramBuckets?: number[];
}

// ============================================================================
// Metric Types
// ============================================================================

abstract class Metric {
  protected name: string;
  protected help: string;
  protected labelNames: string[];
  protected defaultLabels: MetricLabels;
  
  constructor(name: string, help: string, labelNames: string[] = [], defaultLabels: MetricLabels = {}) {
    this.name = name;
    this.help = help;
    this.labelNames = labelNames;
    this.defaultLabels = defaultLabels;
  }
  
  protected labelsToKey(labels: MetricLabels): string {
    const combined = { ...this.defaultLabels, ...labels };
    return JSON.stringify(combined);
  }
  
  protected formatLabels(labels: MetricLabels): string {
    const combined = { ...this.defaultLabels, ...labels };
    const entries = Object.entries(combined);
    if (entries.length === 0) return '';
    
    const formatted = entries
      .map(([key, value]) => `${key}="${this.escapeValue(value)}"`)
      .join(',');
    return `{${formatted}}`;
  }
  
  protected escapeValue(value: string): string {
    return value
      .replace(/\\/g, '\\\\')
      .replace(/"/g, '\\"')
      .replace(/\n/g, '\\n');
  }
  
  abstract collect(): string;
}

// ============================================================================
// Counter Metric
// ============================================================================

export class Counter extends Metric {
  private values: Map<string, CounterValue> = new Map();
  
  inc(labels: MetricLabels = {}, value: number = 1): void {
    const key = this.labelsToKey(labels);
    const existing = this.values.get(key);
    
    if (existing) {
      existing.value += value;
    } else {
      this.values.set(key, { labels, value });
    }
  }
  
  get(labels: MetricLabels = {}): number {
    const key = this.labelsToKey(labels);
    return this.values.get(key)?.value ?? 0;
  }
  
  reset(): void {
    this.values.clear();
  }
  
  collect(): string {
    const lines: string[] = [
      `# HELP ${this.name} ${this.help}`,
      `# TYPE ${this.name} counter`,
    ];
    
    for (const [, entry] of this.values) {
      const labelStr = this.formatLabels(entry.labels);
      lines.push(`${this.name}${labelStr} ${entry.value}`);
    }
    
    return lines.join('\n');
  }
}

// ============================================================================
// Gauge Metric
// ============================================================================

export class Gauge extends Metric {
  private values: Map<string, GaugeValue> = new Map();
  
  set(labels: MetricLabels = {}, value: number): void {
    const key = this.labelsToKey(labels);
    this.values.set(key, { labels, value });
  }
  
  inc(labels: MetricLabels = {}, value: number = 1): void {
    const key = this.labelsToKey(labels);
    const existing = this.values.get(key);
    
    if (existing) {
      existing.value += value;
    } else {
      this.values.set(key, { labels, value });
    }
  }
  
  dec(labels: MetricLabels = {}, value: number = 1): void {
    this.inc(labels, -value);
  }
  
  get(labels: MetricLabels = {}): number {
    const key = this.labelsToKey(labels);
    return this.values.get(key)?.value ?? 0;
  }
  
  reset(): void {
    this.values.clear();
  }
  
  collect(): string {
    const lines: string[] = [
      `# HELP ${this.name} ${this.help}`,
      `# TYPE ${this.name} gauge`,
    ];
    
    for (const [, entry] of this.values) {
      const labelStr = this.formatLabels(entry.labels);
      lines.push(`${this.name}${labelStr} ${entry.value}`);
    }
    
    return lines.join('\n');
  }
}

// ============================================================================
// Histogram Metric
// ============================================================================

export class Histogram extends Metric {
  private values: Map<string, HistogramValue> = new Map();
  private buckets: number[];
  
  constructor(
    name: string,
    help: string,
    labelNames: string[] = [],
    buckets: number[] = [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10],
    defaultLabels: MetricLabels = {}
  ) {
    super(name, help, labelNames, defaultLabels);
    this.buckets = buckets.sort((a, b) => a - b);
  }
  
  observe(labels: MetricLabels = {}, value: number): void {
    const key = this.labelsToKey(labels);
    let existing = this.values.get(key);
    
    if (!existing) {
      const bucketCounts: Record<number, number> = {};
      for (const bucket of this.buckets) {
        bucketCounts[bucket] = 0;
      }
      existing = { labels, sum: 0, count: 0, buckets: bucketCounts };
      this.values.set(key, existing);
    }
    
    existing.sum += value;
    existing.count += 1;
    
    for (const bucket of this.buckets) {
      if (value <= bucket) {
        existing.buckets[bucket] += 1;
      }
    }
  }
  
  /**
   * Time a function and record the duration
   */
  async time<T>(labels: MetricLabels, fn: () => Promise<T>): Promise<T> {
    const start = process.hrtime.bigint();
    try {
      return await fn();
    } finally {
      const end = process.hrtime.bigint();
      const duration = Number(end - start) / 1e9; // Convert to seconds
      this.observe(labels, duration);
    }
  }
  
  /**
   * Create a timer that can be manually stopped
   */
  startTimer(labels: MetricLabels = {}): () => number {
    const start = process.hrtime.bigint();
    return () => {
      const end = process.hrtime.bigint();
      const duration = Number(end - start) / 1e9;
      this.observe(labels, duration);
      return duration;
    };
  }
  
  reset(): void {
    this.values.clear();
  }
  
  collect(): string {
    const lines: string[] = [
      `# HELP ${this.name} ${this.help}`,
      `# TYPE ${this.name} histogram`,
    ];
    
    for (const [, entry] of this.values) {
      const baseLabels = this.formatLabels(entry.labels);
      
      // Output bucket counts (cumulative)
      let cumulative = 0;
      for (const bucket of this.buckets) {
        cumulative += entry.buckets[bucket];
        const bucketLabels = entry.labels;
        const labelStr = this.formatLabels({ ...bucketLabels, le: String(bucket) });
        lines.push(`${this.name}_bucket${labelStr} ${cumulative}`);
      }
      
      // +Inf bucket
      const infLabels = this.formatLabels({ ...entry.labels, le: '+Inf' });
      lines.push(`${this.name}_bucket${infLabels} ${entry.count}`);
      
      // Sum and count
      lines.push(`${this.name}_sum${baseLabels} ${entry.sum}`);
      lines.push(`${this.name}_count${baseLabels} ${entry.count}`);
    }
    
    return lines.join('\n');
  }
}

// ============================================================================
// Metrics Registry
// ============================================================================

export class MetricsRegistry {
  private metrics: Map<string, Metric> = new Map();
  private prefix: string;
  private defaultLabels: MetricLabels;
  private enabled: boolean;
  
  constructor(config: Partial<MetricConfig> = {}) {
    this.prefix = config.prefix || 'mcp';
    this.defaultLabels = config.defaultLabels || {};
    this.enabled = config.enabled !== false;
  }
  
  private prefixName(name: string): string {
    return `${this.prefix}_${name}`;
  }
  
  /**
   * Create and register a counter
   */
  createCounter(name: string, help: string, labelNames: string[] = []): Counter {
    const fullName = this.prefixName(name);
    const counter = new Counter(fullName, help, labelNames, this.defaultLabels);
    this.metrics.set(fullName, counter);
    return counter;
  }
  
  /**
   * Create and register a gauge
   */
  createGauge(name: string, help: string, labelNames: string[] = []): Gauge {
    const fullName = this.prefixName(name);
    const gauge = new Gauge(fullName, help, labelNames, this.defaultLabels);
    this.metrics.set(fullName, gauge);
    return gauge;
  }
  
  /**
   * Create and register a histogram
   */
  createHistogram(
    name: string,
    help: string,
    labelNames: string[] = [],
    buckets?: number[]
  ): Histogram {
    const fullName = this.prefixName(name);
    const histogram = new Histogram(fullName, help, labelNames, buckets, this.defaultLabels);
    this.metrics.set(fullName, histogram);
    return histogram;
  }
  
  /**
   * Get a registered metric by name
   */
  getMetric(name: string): Metric | undefined {
    return this.metrics.get(this.prefixName(name));
  }
  
  /**
   * Collect all metrics in Prometheus format
   */
  collect(): string {
    if (!this.enabled) {
      return '';
    }
    
    const sections: string[] = [];
    
    for (const metric of this.metrics.values()) {
      const output = metric.collect();
      if (output) {
        sections.push(output);
      }
    }
    
    return sections.join('\n\n') + '\n';
  }
  
  /**
   * Reset all metrics
   */
  reset(): void {
    for (const metric of this.metrics.values()) {
      if ('reset' in metric) {
        (metric as any).reset();
      }
    }
  }
}

// ============================================================================
// Default MCP Metrics
// ============================================================================

export interface MCPMetrics {
  requestsTotal: Counter;
  toolInvocationsTotal: Counter;
  toolDurationSeconds: Histogram;
  connectorStatus: Gauge;
  activeConnections: Gauge;
  errorsTotal: Counter;
}

export function createMCPMetrics(registry: MetricsRegistry): MCPMetrics {
  return {
    requestsTotal: registry.createCounter(
      'requests_total',
      'Total number of requests received',
      ['method', 'status']
    ),
    
    toolInvocationsTotal: registry.createCounter(
      'tool_invocations_total',
      'Total number of tool invocations',
      ['tool_name', 'status']
    ),
    
    toolDurationSeconds: registry.createHistogram(
      'tool_duration_seconds',
      'Duration of tool invocations in seconds',
      ['tool_name'],
      [0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10]
    ),
    
    connectorStatus: registry.createGauge(
      'connector_status',
      'Current status of connectors (1=connected, 0=disconnected)',
      ['connector_name']
    ),
    
    activeConnections: registry.createGauge(
      'active_connections',
      'Number of active HTTP connections',
      []
    ),
    
    errorsTotal: registry.createCounter(
      'errors_total',
      'Total number of errors',
      ['type', 'code']
    ),
  };
}

// ============================================================================
// Metrics Endpoint Handler
// ============================================================================

export function createMetricsEndpoint(registry: MetricsRegistry) {
  return function handleMetricsRequest(
    req: http.IncomingMessage,
    res: http.ServerResponse
  ): boolean {
    if (req.url === '/metrics' && req.method === 'GET') {
      try {
        const metrics = registry.collect();
        
        res.writeHead(200, {
          'Content-Type': 'text/plain; version=0.0.4; charset=utf-8',
          'Cache-Control': 'no-cache, no-store, must-revalidate',
        });
        res.end(metrics);
        return true;
      } catch (error) {
        res.writeHead(500, { 'Content-Type': 'text/plain' });
        res.end('Error collecting metrics');
        return true;
      }
    }
    
    return false;
  };
}

// ============================================================================
// Exports
// ============================================================================
export default MetricsRegistry;
