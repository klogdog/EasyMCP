/**
 * OpenTelemetry Tracing System Template
 * Generated by EasyMCP
 * 
 * Provides distributed tracing with OpenTelemetry-compatible API:
 * - Trace context propagation
 * - Span creation and management
 * - Tool invocation tracing
 * - Connector call tracing
 */

// ============================================================================
// Types
// ============================================================================

export type SpanKind = 'internal' | 'server' | 'client' | 'producer' | 'consumer';

export type SpanStatusCode = 'unset' | 'ok' | 'error';

export interface SpanStatus {
  code: SpanStatusCode;
  message?: string;
}

export interface SpanAttributes {
  [key: string]: string | number | boolean | string[] | number[] | boolean[];
}

export interface SpanEvent {
  name: string;
  time: number;
  attributes?: SpanAttributes;
}

export interface SpanLink {
  traceId: string;
  spanId: string;
  attributes?: SpanAttributes;
}

export interface SpanContext {
  traceId: string;
  spanId: string;
  traceFlags: number;
  traceState?: string;
}

export interface TracerConfig {
  serviceName: string;
  serviceVersion?: string;
  enabled?: boolean;
  sampleRate?: number;
  exporter?: TraceExporter;
}

export interface TraceExporter {
  export(spans: Span[]): Promise<void>;
  shutdown(): Promise<void>;
}

// ============================================================================
// Utilities
// ============================================================================

function generateId(length: number): string {
  const chars = '0123456789abcdef';
  let result = '';
  for (let i = 0; i < length; i++) {
    result += chars[Math.floor(Math.random() * chars.length)];
  }
  return result;
}

function generateTraceId(): string {
  return generateId(32);
}

function generateSpanId(): string {
  return generateId(16);
}

// ============================================================================
// Span Class
// ============================================================================

export class Span {
  private _traceId: string;
  private _spanId: string;
  private _parentSpanId?: string;
  private _name: string;
  private _kind: SpanKind;
  private _startTime: number;
  private _endTime?: number;
  private _attributes: SpanAttributes = {};
  private _events: SpanEvent[] = [];
  private _links: SpanLink[] = [];
  private _status: SpanStatus = { code: 'unset' };
  private _ended: boolean = false;
  
  constructor(
    name: string,
    traceId: string,
    spanId: string,
    parentSpanId?: string,
    kind: SpanKind = 'internal'
  ) {
    this._name = name;
    this._traceId = traceId;
    this._spanId = spanId;
    this._parentSpanId = parentSpanId;
    this._kind = kind;
    this._startTime = Date.now();
  }
  
  get traceId(): string {
    return this._traceId;
  }
  
  get spanId(): string {
    return this._spanId;
  }
  
  get parentSpanId(): string | undefined {
    return this._parentSpanId;
  }
  
  get name(): string {
    return this._name;
  }
  
  get context(): SpanContext {
    return {
      traceId: this._traceId,
      spanId: this._spanId,
      traceFlags: 1, // Sampled
    };
  }
  
  /**
   * Set span attributes
   */
  setAttributes(attributes: SpanAttributes): this {
    Object.assign(this._attributes, attributes);
    return this;
  }
  
  /**
   * Set a single attribute
   */
  setAttribute(key: string, value: string | number | boolean): this {
    this._attributes[key] = value;
    return this;
  }
  
  /**
   * Add an event to the span
   */
  addEvent(name: string, attributes?: SpanAttributes): this {
    this._events.push({
      name,
      time: Date.now(),
      attributes,
    });
    return this;
  }
  
  /**
   * Add a link to another span
   */
  addLink(context: SpanContext, attributes?: SpanAttributes): this {
    this._links.push({
      traceId: context.traceId,
      spanId: context.spanId,
      attributes,
    });
    return this;
  }
  
  /**
   * Set span status
   */
  setStatus(status: SpanStatus): this {
    this._status = status;
    return this;
  }
  
  /**
   * Record an exception
   */
  recordException(error: Error): this {
    this.addEvent('exception', {
      'exception.type': error.name,
      'exception.message': error.message,
      'exception.stacktrace': error.stack || '',
    });
    this.setStatus({ code: 'error', message: error.message });
    return this;
  }
  
  /**
   * End the span
   */
  end(): void {
    if (this._ended) return;
    this._endTime = Date.now();
    this._ended = true;
  }
  
  /**
   * Check if span has ended
   */
  isEnded(): boolean {
    return this._ended;
  }
  
  /**
   * Get duration in milliseconds
   */
  getDuration(): number {
    const endTime = this._endTime || Date.now();
    return endTime - this._startTime;
  }
  
  /**
   * Export span data
   */
  toJSON(): object {
    return {
      traceId: this._traceId,
      spanId: this._spanId,
      parentSpanId: this._parentSpanId,
      name: this._name,
      kind: this._kind,
      startTime: this._startTime,
      endTime: this._endTime,
      duration: this.getDuration(),
      attributes: this._attributes,
      events: this._events,
      links: this._links,
      status: this._status,
    };
  }
}

// ============================================================================
// Tracer Class
// ============================================================================

export class Tracer {
  private serviceName: string;
  private serviceVersion: string;
  private enabled: boolean;
  private sampleRate: number;
  private exporter?: TraceExporter;
  private activeSpans: Map<string, Span> = new Map();
  private completedSpans: Span[] = [];
  private currentTraceId?: string;
  private currentSpanId?: string;
  
  constructor(config: TracerConfig) {
    this.serviceName = config.serviceName;
    this.serviceVersion = config.serviceVersion || '1.0.0';
    this.enabled = config.enabled !== false;
    this.sampleRate = config.sampleRate || 1.0;
    this.exporter = config.exporter;
  }
  
  /**
   * Check if tracing is enabled and should sample
   */
  private shouldSample(): boolean {
    return this.enabled && Math.random() < this.sampleRate;
  }
  
  /**
   * Start a new span
   */
  startSpan(name: string, options: { kind?: SpanKind; attributes?: SpanAttributes; parentContext?: SpanContext } = {}): Span {
    if (!this.shouldSample()) {
      // Return a no-op span
      return new Span(name, '0'.repeat(32), '0'.repeat(16));
    }
    
    const parentContext = options.parentContext || this.getCurrentContext();
    const traceId = parentContext?.traceId || generateTraceId();
    const spanId = generateSpanId();
    const parentSpanId = parentContext?.spanId;
    
    const span = new Span(name, traceId, spanId, parentSpanId, options.kind);
    
    if (options.attributes) {
      span.setAttributes(options.attributes);
    }
    
    // Add service attributes
    span.setAttributes({
      'service.name': this.serviceName,
      'service.version': this.serviceVersion,
    });
    
    this.activeSpans.set(spanId, span);
    this.currentTraceId = traceId;
    this.currentSpanId = spanId;
    
    return span;
  }
  
  /**
   * Get current span context
   */
  getCurrentContext(): SpanContext | undefined {
    if (!this.currentTraceId || !this.currentSpanId) {
      return undefined;
    }
    return {
      traceId: this.currentTraceId,
      spanId: this.currentSpanId,
      traceFlags: 1,
    };
  }
  
  /**
   * End a span and record it
   */
  endSpan(span: Span): void {
    span.end();
    this.activeSpans.delete(span.spanId);
    this.completedSpans.push(span);
    
    // Reset current span to parent if exists
    if (span.parentSpanId) {
      this.currentSpanId = span.parentSpanId;
    } else {
      this.currentSpanId = undefined;
      this.currentTraceId = undefined;
    }
  }
  
  /**
   * Trace a function execution
   */
  async trace<T>(
    name: string,
    fn: (span: Span) => Promise<T>,
    options: { kind?: SpanKind; attributes?: SpanAttributes } = {}
  ): Promise<T> {
    const span = this.startSpan(name, options);
    
    try {
      const result = await fn(span);
      span.setStatus({ code: 'ok' });
      return result;
    } catch (error) {
      span.recordException(error as Error);
      throw error;
    } finally {
      this.endSpan(span);
    }
  }
  
  /**
   * Flush completed spans to exporter
   */
  async flush(): Promise<void> {
    if (this.exporter && this.completedSpans.length > 0) {
      await this.exporter.export(this.completedSpans);
      this.completedSpans = [];
    }
  }
  
  /**
   * Shutdown the tracer
   */
  async shutdown(): Promise<void> {
    await this.flush();
    if (this.exporter) {
      await this.exporter.shutdown();
    }
  }
}

// ============================================================================
// Console Exporter (for development)
// ============================================================================

export class ConsoleExporter implements TraceExporter {
  async export(spans: Span[]): Promise<void> {
    for (const span of spans) {
      console.log('[TRACE]', JSON.stringify(span.toJSON(), null, 2));
    }
  }
  
  async shutdown(): Promise<void> {
    // No-op
  }
}

// ============================================================================
// Context Propagation (W3C Trace Context)
// ============================================================================

export function extractTraceContext(headers: Record<string, string | string[] | undefined>): SpanContext | undefined {
  const traceparent = headers['traceparent'];
  if (!traceparent || typeof traceparent !== 'string') {
    return undefined;
  }
  
  // Format: version-traceId-spanId-traceFlags
  const parts = traceparent.split('-');
  if (parts.length !== 4) {
    return undefined;
  }
  
  const [version, traceId, spanId, flags] = parts;
  
  if (version !== '00' || traceId.length !== 32 || spanId.length !== 16) {
    return undefined;
  }
  
  return {
    traceId,
    spanId,
    traceFlags: parseInt(flags, 16),
    traceState: typeof headers['tracestate'] === 'string' ? headers['tracestate'] : undefined,
  };
}

export function injectTraceContext(span: Span, headers: Record<string, string>): void {
  const context = span.context;
  headers['traceparent'] = `00-${context.traceId}-${context.spanId}-01`;
  if (context.traceState) {
    headers['tracestate'] = context.traceState;
  }
}

// ============================================================================
// Exports
// ============================================================================
export default Tracer;
