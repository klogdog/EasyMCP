/**
 * MCP Server Entry Point Template
 * Generated by EasyMCP
 * 
 * This file serves as the main entry point for the MCP server.
 * It handles JSON-RPC 2.0 requests, manages tool/connector lifecycles,
 * and provides health monitoring capabilities.
 */

// ============================================================================
// Placeholder Imports - Populated during code generation
// ============================================================================
{{TOOL_IMPORTS}}
{{CONNECTOR_IMPORTS}}

// ============================================================================
// Core Dependencies
// ============================================================================
import * as http from 'http';
import * as fs from 'fs';
import * as yaml from 'js-yaml';
import { v4 as uuidv4 } from 'uuid';

// ============================================================================
// Types
// ============================================================================

interface ServerConfig {
  port: number;
  host?: string;
  logging?: {
    level?: 'debug' | 'info' | 'warn' | 'error';
    format?: 'json' | 'pretty';
    file?: string;
  };
  shutdown?: {
    timeout?: number;
    gracePeriod?: number;
  };
}

interface MCPConfig {
  server: ServerConfig;
  tools?: Record<string, unknown>;
  connectors?: Record<string, unknown>;
}

interface JsonRpcRequest {
  jsonrpc: '2.0';
  id: string | number | null;
  method: string;
  params?: unknown;
}

interface JsonRpcResponse {
  jsonrpc: '2.0';
  id: string | number | null;
  result?: unknown;
  error?: JsonRpcError;
}

interface JsonRpcError {
  code: number;
  message: string;
  data?: unknown;
}

interface LogEntry {
  timestamp: string;
  level: string;
  message: string;
  requestId?: string;
  context?: Record<string, unknown>;
}

interface HealthStatus {
  status: 'ok' | 'degraded' | 'unhealthy';
  uptime: number;
  timestamp: string;
  tools: string[];
  connectors: string[];
  checks?: Record<string, boolean>;
}

// ============================================================================
// JSON-RPC Error Codes (per JSON-RPC 2.0 spec)
// ============================================================================
const JSON_RPC_ERRORS = {
  PARSE_ERROR: { code: -32700, message: 'Parse error' },
  INVALID_REQUEST: { code: -32600, message: 'Invalid Request' },
  METHOD_NOT_FOUND: { code: -32601, message: 'Method not found' },
  INVALID_PARAMS: { code: -32602, message: 'Invalid params' },
  INTERNAL_ERROR: { code: -32603, message: 'Internal error' },
  // Server errors reserved: -32000 to -32099
  TOOL_ERROR: { code: -32000, message: 'Tool execution error' },
  CONNECTOR_ERROR: { code: -32001, message: 'Connector error' },
  TIMEOUT_ERROR: { code: -32002, message: 'Request timeout' },
} as const;

// ============================================================================
// Configuration Loading
// ============================================================================

function loadConfig(): MCPConfig {
  const configPath = process.env.MCP_CONFIG_PATH;
  
  if (!configPath) {
    throw new Error('MCP_CONFIG_PATH environment variable is not set');
  }
  
  if (!fs.existsSync(configPath)) {
    throw new Error(`Configuration file not found: ${configPath}`);
  }
  
  try {
    const configContent = fs.readFileSync(configPath, 'utf8');
    const config = yaml.load(configContent) as MCPConfig;
    
    // Validate required fields
    validateConfig(config);
    
    return config;
  } catch (error) {
    if (error instanceof yaml.YAMLException) {
      throw new Error(`Invalid YAML in config file: ${error.message}`);
    }
    throw error;
  }
}

function validateConfig(config: MCPConfig): void {
  if (!config) {
    throw new Error('Configuration is empty');
  }
  
  if (!config.server) {
    throw new Error('Missing required field: server');
  }
  
  if (typeof config.server.port !== 'number') {
    throw new Error('server.port must be a number');
  }
  
  if (config.server.port < 1 || config.server.port > 65535) {
    throw new Error('server.port must be between 1 and 65535');
  }
  
  // Validate logging config if present
  if (config.server.logging) {
    const validLevels = ['debug', 'info', 'warn', 'error'];
    if (config.server.logging.level && !validLevels.includes(config.server.logging.level)) {
      throw new Error(`Invalid log level: ${config.server.logging.level}`);
    }
    
    const validFormats = ['json', 'pretty'];
    if (config.server.logging.format && !validFormats.includes(config.server.logging.format)) {
      throw new Error(`Invalid log format: ${config.server.logging.format}`);
    }
  }
}

// ============================================================================
// Logging
// ============================================================================

class Logger {
  private level: string;
  private format: 'json' | 'pretty';
  private fileStream: fs.WriteStream | null = null;
  private levels: Record<string, number> = {
    debug: 0,
    info: 1,
    warn: 2,
    error: 3,
  };

  constructor(config?: ServerConfig['logging']) {
    this.level = config?.level || 'info';
    this.format = config?.format || 'json';
    
    if (config?.file) {
      this.fileStream = fs.createWriteStream(config.file, { flags: 'a' });
    }
  }

  private shouldLog(level: string): boolean {
    return this.levels[level] >= this.levels[this.level];
  }

  private formatEntry(entry: LogEntry): string {
    if (this.format === 'json') {
      return JSON.stringify(entry);
    }
    
    // Pretty format
    const parts = [
      `[${entry.timestamp}]`,
      `[${entry.level.toUpperCase()}]`,
    ];
    
    if (entry.requestId) {
      parts.push(`[${entry.requestId}]`);
    }
    
    parts.push(entry.message);
    
    if (entry.context && Object.keys(entry.context).length > 0) {
      parts.push(JSON.stringify(entry.context));
    }
    
    return parts.join(' ');
  }

  private write(entry: LogEntry): void {
    const formatted = this.formatEntry(entry);
    console.log(formatted);
    
    if (this.fileStream) {
      this.fileStream.write(formatted + '\n');
    }
  }

  log(level: string, message: string, requestId?: string, context?: Record<string, unknown>): void {
    if (!this.shouldLog(level)) return;
    
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      requestId,
      context,
    };
    
    this.write(entry);
  }

  debug(message: string, requestId?: string, context?: Record<string, unknown>): void {
    this.log('debug', message, requestId, context);
  }

  info(message: string, requestId?: string, context?: Record<string, unknown>): void {
    this.log('info', message, requestId, context);
  }

  warn(message: string, requestId?: string, context?: Record<string, unknown>): void {
    this.log('warn', message, requestId, context);
  }

  error(message: string, requestId?: string, context?: Record<string, unknown>): void {
    this.log('error', message, requestId, context);
  }

  async flush(): Promise<void> {
    if (this.fileStream) {
      return new Promise((resolve) => {
        this.fileStream!.end(() => resolve());
      });
    }
  }

  close(): void {
    if (this.fileStream) {
      this.fileStream.end();
      this.fileStream = null;
    }
  }
}

// ============================================================================
// Tool & Connector Registries
// ============================================================================

interface Tool {
  name: string;
  description: string;
  inputSchema: Record<string, unknown>;
  handler: (args: unknown) => Promise<unknown>;
}

interface Connector {
  name: string;
  type: string;
  isConnected: () => boolean;
  connect: () => Promise<void>;
  disconnect: () => Promise<void>;
}

const toolRegistry = new Map<string, Tool>();
const connectorRegistry = new Map<string, Connector>();

function registerTool(tool: Tool): void {
  toolRegistry.set(tool.name, tool);
}

function registerConnector(connector: Connector): void {
  connectorRegistry.set(connector.name, connector);
}

function getToolList(): string[] {
  return Array.from(toolRegistry.keys());
}

function getConnectorList(): string[] {
  return Array.from(connectorRegistry.keys());
}

// ============================================================================
// Placeholder for Tool/Connector Registration
// ============================================================================
{{TOOL_REGISTRATION}}

// ============================================================================
// JSON-RPC Handler
// ============================================================================

async function handleJsonRpc(request: JsonRpcRequest, requestId: string, logger: Logger): Promise<JsonRpcResponse> {
  const baseResponse = {
    jsonrpc: '2.0' as const,
    id: request.id,
  };

  logger.debug(`Processing JSON-RPC method: ${request.method}`, requestId);

  try {
    switch (request.method) {
      case 'tools/list': {
        const tools = Array.from(toolRegistry.values()).map(t => ({
          name: t.name,
          description: t.description,
          inputSchema: t.inputSchema,
        }));
        return { ...baseResponse, result: { tools } };
      }

      case 'tools/call': {
        const params = request.params as { name: string; arguments?: unknown };
        if (!params || typeof params.name !== 'string') {
          return {
            ...baseResponse,
            error: { ...JSON_RPC_ERRORS.INVALID_PARAMS, data: 'Missing tool name' },
          };
        }

        const tool = toolRegistry.get(params.name);
        if (!tool) {
          return {
            ...baseResponse,
            error: { ...JSON_RPC_ERRORS.METHOD_NOT_FOUND, data: `Tool not found: ${params.name}` },
          };
        }

        try {
          const result = await tool.handler(params.arguments);
          return { ...baseResponse, result: { content: [{ type: 'text', text: JSON.stringify(result) }] } };
        } catch (toolError) {
          logger.error(`Tool execution failed: ${params.name}`, requestId, {
            error: toolError instanceof Error ? toolError.message : String(toolError),
          });
          return {
            ...baseResponse,
            error: {
              ...JSON_RPC_ERRORS.TOOL_ERROR,
              data: toolError instanceof Error ? toolError.message : 'Unknown error',
            },
          };
        }
      }

      case 'resources/list': {
        // Return empty list for now - can be extended
        return { ...baseResponse, result: { resources: [] } };
      }

      case 'prompts/list': {
        // Return empty list for now - can be extended
        return { ...baseResponse, result: { prompts: [] } };
      }

      case 'initialize': {
        return {
          ...baseResponse,
          result: {
            protocolVersion: '2024-11-05',
            capabilities: {
              tools: { listChanged: true },
              resources: { subscribe: false, listChanged: true },
              prompts: { listChanged: true },
            },
            serverInfo: {
              name: 'mcp-server',
              version: '1.0.0',
            },
          },
        };
      }

      case 'notifications/initialized': {
        // Acknowledgement notification
        return { ...baseResponse, result: {} };
      }

      default:
        return {
          ...baseResponse,
          error: { ...JSON_RPC_ERRORS.METHOD_NOT_FOUND, data: request.method },
        };
    }
  } catch (error) {
    logger.error(`JSON-RPC handler error`, requestId, {
      method: request.method,
      error: error instanceof Error ? error.message : String(error),
    });
    return {
      ...baseResponse,
      error: {
        ...JSON_RPC_ERRORS.INTERNAL_ERROR,
        data: error instanceof Error ? error.message : 'Unknown error',
      },
    };
  }
}

// ============================================================================
// HTTP Request Parsing
// ============================================================================

function parseRequestBody(req: http.IncomingMessage): Promise<string> {
  return new Promise((resolve, reject) => {
    let body = '';
    req.on('data', chunk => (body += chunk));
    req.on('end', () => resolve(body));
    req.on('error', reject);
  });
}

function parseJsonRpcRequest(body: string): JsonRpcRequest | JsonRpcResponse {
  try {
    const parsed = JSON.parse(body);
    
    if (parsed.jsonrpc !== '2.0') {
      return {
        jsonrpc: '2.0',
        id: null,
        error: { ...JSON_RPC_ERRORS.INVALID_REQUEST, data: 'Invalid JSON-RPC version' },
      };
    }
    
    if (typeof parsed.method !== 'string') {
      return {
        jsonrpc: '2.0',
        id: parsed.id ?? null,
        error: { ...JSON_RPC_ERRORS.INVALID_REQUEST, data: 'Missing method' },
      };
    }
    
    return parsed as JsonRpcRequest;
  } catch {
    return {
      jsonrpc: '2.0',
      id: null,
      error: JSON_RPC_ERRORS.PARSE_ERROR,
    };
  }
}

// ============================================================================
// Health Check
// ============================================================================

function getHealthStatus(startTime: number): HealthStatus {
  const connectorChecks: Record<string, boolean> = {};
  
  for (const [name, connector] of connectorRegistry) {
    try {
      connectorChecks[name] = connector.isConnected();
    } catch {
      connectorChecks[name] = false;
    }
  }
  
  const allConnectorsHealthy = Object.values(connectorChecks).every(v => v);
  
  return {
    status: allConnectorsHealthy ? 'ok' : (Object.values(connectorChecks).some(v => v) ? 'degraded' : 'unhealthy'),
    uptime: Math.floor((Date.now() - startTime) / 1000),
    timestamp: new Date().toISOString(),
    tools: getToolList(),
    connectors: getConnectorList(),
    checks: connectorChecks,
  };
}

// ============================================================================
// Main Server
// ============================================================================

async function main(): Promise<void> {
  const startTime = Date.now();
  
  // Load configuration
  const config = loadConfig();
  
  // Initialize logger
  const logger = new Logger(config.server.logging);
  logger.info('Starting MCP Server...');
  logger.info(`Configuration loaded from: ${process.env.MCP_CONFIG_PATH}`);
  
  // Initialize connectors
  for (const [name, connector] of connectorRegistry) {
    try {
      await connector.connect();
      logger.info(`Connector initialized: ${name}`);
    } catch (error) {
      logger.error(`Failed to initialize connector: ${name}`, undefined, {
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }
  
  // Track active connections for graceful shutdown
  const activeConnections = new Set<http.ServerResponse>();
  
  // Create HTTP server
  const server = http.createServer(async (req, res) => {
    const requestId = uuidv4();
    activeConnections.add(res);
    
    res.on('close', () => {
      activeConnections.delete(res);
    });
    
    try {
      // Health endpoint
      if (req.url === '/health' && req.method === 'GET') {
        const health = getHealthStatus(startTime);
        res.writeHead(health.status === 'ok' ? 200 : (health.status === 'degraded' ? 200 : 503), {
          'Content-Type': 'application/json',
        });
        res.end(JSON.stringify(health));
        logger.debug('Health check requested', requestId, { status: health.status });
        return;
      }
      
      // MCP JSON-RPC endpoint
      if (req.url === '/mcp' && req.method === 'POST') {
        const body = await parseRequestBody(req);
        logger.debug('Received JSON-RPC request', requestId, { bodyLength: body.length });
        
        const parsed = parseJsonRpcRequest(body);
        
        // If parse returned an error response
        if ('error' in parsed) {
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify(parsed));
          logger.warn('JSON-RPC parse error', requestId, { error: parsed.error });
          return;
        }
        
        // Handle the request
        const response = await handleJsonRpc(parsed, requestId, logger);
        
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify(response));
        
        if (response.error) {
          logger.warn('JSON-RPC error response', requestId, { 
            method: parsed.method,
            errorCode: response.error.code,
          });
        } else {
          logger.debug('JSON-RPC success', requestId, { method: parsed.method });
        }
        return;
      }
      
      // 404 for all other routes
      res.writeHead(404, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ error: 'Not Found' }));
      logger.debug('404 Not Found', requestId, { url: req.url, method: req.method });
      
    } catch (error) {
      // Error middleware - catch unhandled errors
      logger.error('Unhandled request error', requestId, {
        url: req.url,
        method: req.method,
        error: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined,
      });
      
      if (!res.headersSent) {
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
          jsonrpc: '2.0',
          id: null,
          error: JSON_RPC_ERRORS.INTERNAL_ERROR,
        }));
      }
    }
  });
  
  // Graceful shutdown handler
  let isShuttingDown = false;
  const shutdownTimeout = config.server.shutdown?.timeout ?? 30000;
  const gracePeriod = config.server.shutdown?.gracePeriod ?? 5000;
  
  async function gracefulShutdown(signal: string): Promise<void> {
    if (isShuttingDown) return;
    isShuttingDown = true;
    
    logger.info(`Received ${signal}, initiating graceful shutdown...`);
    
    // Stop accepting new connections
    server.close();
    
    // Wait for grace period to allow in-flight requests to complete
    await new Promise(resolve => setTimeout(resolve, gracePeriod));
    
    // Close active connections
    for (const connection of activeConnections) {
      try {
        connection.end();
      } catch {
        // Ignore errors when closing connections
      }
    }
    
    // Disconnect all connectors
    for (const [name, connector] of connectorRegistry) {
      try {
        await connector.disconnect();
        logger.info(`Connector disconnected: ${name}`);
      } catch (error) {
        logger.error(`Error disconnecting connector: ${name}`, undefined, {
          error: error instanceof Error ? error.message : String(error),
        });
      }
    }
    
    // Flush logs
    await logger.flush();
    logger.close();
    
    logger.info('Shutdown complete');
    
    // Force exit after timeout
    const forceExitTimer = setTimeout(() => {
      console.error('Forced exit after shutdown timeout');
      process.exit(1);
    }, shutdownTimeout);
    
    // Don't keep the process alive just for this timer
    forceExitTimer.unref();
    
    process.exit(0);
  }
  
  // Register signal handlers
  process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
  process.on('SIGINT', () => gracefulShutdown('SIGINT'));
  
  // Handle uncaught exceptions
  process.on('uncaughtException', (error) => {
    logger.error('Uncaught exception', undefined, {
      error: error.message,
      stack: error.stack,
    });
    gracefulShutdown('uncaughtException');
  });
  
  // Handle unhandled promise rejections
  process.on('unhandledRejection', (reason) => {
    logger.error('Unhandled rejection', undefined, {
      reason: reason instanceof Error ? reason.message : String(reason),
    });
  });
  
  // Start the server
  const host = config.server.host || '0.0.0.0';
  const port = config.server.port;
  
  server.listen(port, host, () => {
    logger.info(`MCP Server listening on ${host}:${port}`);
    logger.info(`Tools registered: ${getToolList().join(', ') || 'none'}`);
    logger.info(`Connectors registered: ${getConnectorList().join(', ') || 'none'}`);
  });
}

// ============================================================================
// Exports for testing
// ============================================================================
export {
  loadConfig,
  validateConfig,
  Logger,
  handleJsonRpc,
  parseJsonRpcRequest,
  getHealthStatus,
  registerTool,
  registerConnector,
  getToolList,
  getConnectorList,
  toolRegistry,
  connectorRegistry,
  JSON_RPC_ERRORS,
  // Types
  type ServerConfig,
  type MCPConfig,
  type JsonRpcRequest,
  type JsonRpcResponse,
  type JsonRpcError,
  type LogEntry,
  type HealthStatus,
  type Tool,
  type Connector,
};

// Run main if this is the entry point
main().catch(error => {
  console.error('Fatal error:', error);
  process.exit(1);
});
